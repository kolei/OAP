[содержание](/readme.md)  

# Функции в программировании.

До этого мы изучали императивный (структурный) тип программирования. Хотя это наиболее естественный тип работы для компьютера, но с точки зрения разработки программ людьми он не годится для разработки сколько нибудь сложных проектов, человек просто не в состоянии запомнить весь этот код.

Для упрощения работы стали выделять обособленные или повторяющиеся части программы в отдельные подпрограммы.

**Подпрограмма** - это отдельная функционально независимая часть программы. Любая подпрограмма обладает той же структурой, которой обладает и вся программа.

Подпрограммы решают три важные задачи:

* избавляют от необходимости многократно повторять в тексте программы аналогичные фрагменты;
* улучшают структуру программы, облегчая ее понимание;
* повышают устойчивость к ошибкам программирования и непредвидимым последствиям при модификациях программы.

Вызов подпрограммы происходит при каждом употреблении ее имени в основной (или вызывающей) программе. При вызове подпрограммы выполнение основной программы приостанавливается, и управление передается в подпрограмму, где выполняются команды, заданные в ней. Подпрограмма завершается, если выполнены все ее процедуры или по специальной команде выхода из подпрограммы *return*. По окончании работы подпрограммы управление возвращается основной программе, иначе говоря, к первой команде, следующей за обращением к этой подпрограмме.

## Область видимости

При разбиении программы на подпрограммы возникает вопрос с областью видимости переменных объявленных в основном модуле, в подпрограммах и модулях.

Область видимости указывает интерпретатору, когда переменная/функция видимы. Другими словами, область видимости определяет, когда и где вы можете использовать свои переменные, функции, и т.д.

Python содержит три разных типа области видимости:

* Глобальная область видимости
* Локальная область видимости
* Нелокальная область видимости (была добавлена в Python 3)

### Глобальная область видимости

Глобальный контекст подразумевает, что переменная является глобальной, она определена вне любой из функций и доступна любой функции в программе.

Например:

```py
name = "Tom"
 
def say_hi():
    print("Hello", name)
 
def say_bye():
    print("Good bye", name)
 
say_hi()  # Hello Tom
say_bye() # Good bye Tom
```

Здесь переменная name является глобальной и имеет глобальную область видимости. И обе определенные здесь функции могут свободно ее использовать.

### Локальная область видимости

В отличие от глобальных переменных локальная переменная определяется внутри функции и доступна только из этой функции, то есть имеет локальную область видимости:

```py
def say_hi():
    name = "Sam"
    surname = "Johnson"
    print("Hello", name, surname)
 
 
def say_bye():
    name = "Tom"
    print("Good bye", name)
 
say_hi()  # Hello Sam Johnson
say_bye() # Good bye Tom
```

В данном случае в каждой из двух функций определяется локальная переменная *name*. И хотя эти переменные называются одинаково, но тем не менее это две разных переменных, каждая из которых доступна только в рамках своей функции. Также в функции *say_hi* определена переменная *surname*, которая также является локальной, поэтому в функции *say_bye* мы ее использовать не сможем.

Есть еще один вариант определения переменной, когда локальная переменная скрывают глобальную с тем же именем:

```py
name = "Tom"
  
def say_hi():
    print("Hello", name)

def say_bye():
    name = "Bob"
    print("Good bye", name)
 
say_hi()  # Hello Tom
say_bye() # Good bye Bob
```

Здесь определена глобальная переменная *name*. Однако в функции *say_bye* определена локальная переменная с тем же именем name. И если функция *say_hi* использует глобальную переменную, то функция *say_bye* использует локальную переменную, которая скрывает глобальную.

Если же мы хотим изменить в локальной функции глобальную переменную, а не определить локальную, то необходимо использовать ключевое слово global:

```py
def say_bye():
    global name
    name = "Bob"
    print("Good bye", name)
```

В Python, как и во многих других языках программирования, не рекомендуется использовать глобальные переменные. Единственной допустимой практикой является определение небольшого числа глобальных констант, которые не изменяются в процессе работы программы.

```py
PI = 3.14
 
# вычисление площади круга
def get_circle_square(radius):
    print("Площадь круга с радиусом", radius, "равна", PI * radius * radius)
 
get_circle_square(50)
```

В данном случае число *3.14* представлено константой *PI*. Понятно, что это значение в принципе не изменится, поэтому его можно вынести из функций и определить в виде константы. Как правило, имя константы определяется заглавными буквами.

## Неочевидные моменты видимости переменных

Рассмотрим пример:

```
x = 10
def foo():
    print(x)
    x += 1
```

Питон при попытке выполнить функцию *foo* выдаст ошибку. Это происходит потому, что локальная переменная *х* перекрывает глобальную, но на момент выполнения команды *print* она еще не определена. Для исправления такой ситуации нужно добавить команду *global х* перед функцией *print*.

## Как организовать совместный доступ к глобальным переменным для нескольких модулей?

Канонический способ организовать подобный доступ - это создать отдельный модуль (часто называемый config или cfg). Просто добавьте *import config* в каждый модуль приложения. При этом модуль становится доступен через глобальное имя. Поскольку существует только один экземпляр модуля, любые изменения, произведённые в модуле отражаются везде. Например:

```py
#config.py
x = 0
```

```py
#mod.py

import config
config.x = 1
```

```py
#main.py

import config
import mod
print(config.x)
```

## Функции в Python

### Именные функции, инструкция def

Функция – это структура, которую вы определяете. Вам нужно решить, будут ли в ней аргументы, или нет. Вы можете добавить как аргументы ключевых слов, так и готовые по умолчанию. **Функция** – это блок кода, который начинается с ключевого слова def, названия функции и двоеточия.

Определим простейшую функцию:

```py
def add(x, y):
    return x + y
```

Инструкция *return* говорит, что нужно вернуть значение. В нашем случае функция возвращает сумму x и y.

Теперь мы ее можем вызвать:

```py
add(1, 10)
#11
add('abc', 'def')
#'abcdef'
```

Функция может быть любой сложности и возвращать любые объекты (списки, кортежи, и даже функции!):

```py
def newfunc(n):
    def myfunc(x):
        return x + n
    return myfunc

new = newfunc(100)  # new - это функция
new(200)
#300
```

Функция может и не заканчиваться инструкцией *return*, при этом функция вернет значение None:

```py
def func():
    pass
print(func())
#None
```

### Пустая функция

Иногда, когда вы пишете какой-нибудь код, вам нужно просто ввести определения функции, которое не содержит в себе код.

```py
def empty_function():
    pass
```

А вот здесь кое-что новенькое: оператор *pass*. Это пустая операция, это означает, что когда оператор pass выполняется, не происходит ничего.

## Аргументы функции

Функция может принимать произвольное количество аргументов или не принимать их вовсе. Также распространены функции с произвольным числом аргументов, функции с позиционными и именованными аргументами, обязательными и необязательными.

Параметры, указываемые при описании функции, называются *формальными*, а параметры, указываемые при вызове – *фактическими*.

### Обязательные аргументы функции

Если при создании функции мы указали количество передаваемых ей аргументов и их порядок, то и вызывать ее мы должны с тем же количеством аргументов, заданных в нужном порядке.

```py
def bigger(a,b):
    if a > b:
        print a
    else:
       print b

# В описании функции указано, что она принимает 2 аргумента
 
# Корректное использование функции
bigger(5,6)
 
# Некорректное использование функции
bigger()
bigger(3)
bigger(12,7,3)        
```

### Аргументы - ключевые слова

Аргументы одновременно являются ключевыми словами. Благодаря ключевым аргументам, вы можете задавать произвольный (то есть не такой каким он описан при создании функции) порядок аргументов.

Например:

```py
def person(name, age):
    print name, "is", age, "years old"
 
# Хотя в описании функции первым аргументом идет имя, мы можем вызвать функцию вот так
 
person(age=23, name="John")
```

### Аргументы, заданные по-умолчанию

Аргумент по умолчанию, это аргумент, значение для которого задано изначально, при создании функции.

```py
def space(planet_name, center="Star"):
    print planet_name, "is orbiting a", center
 
# Можно вызвать функцию space так:
space("Mars")
# В результате получим: Mars is orbiting a Star
 
# Можно вызвать функцию space иначе:
space("Mars", "Black Hole")
# В результате получим: Mars is orbiting a Black Hole
```

Функция также может принимать переменное количество позиционных аргументов, тогда перед именем аргумента ставится *:

```py
def func(*args):
    return args

func(1, 2, 3, 'abc')
#(1, 2, 3, 'abc')

func()
#()

func(1)
#(1,)
```

Как видно из примера, args - это кортеж из всех переданных аргументов функции, и с переменной можно работать также, как и с кортежем.

Функция может принимать и произвольное число именованных аргументов, тогда перед именем ставится **. Тут надо понимать, что кварги это не пришельцы из космоса, а название ассоциативного массива (или кортежа в нотации питона) полученное сокращением: k(ey)w(ord)args.

```py
def func(**kwargs): #KeyWordARGS
    return kwargs

func(a=1, b=2, c=3)
#{'a': 1, 'c': 3, 'b': 2}

func()
#{}

func(a='python')
#{'a': 'python'}
```

В переменной kwargs у нас хранится словарь, с которым мы, опять-таки, можем делать все, что нам заблагорассудится.

### Типы агрументов функций

Вообще самому питону не нужно явно указывать типы переменных, т.к. все типы в питоне являются объектами, то питон "знает" и название и класс объекта и значение переданного аргумента.

### Автоматическое документирование

Считается хорошей практикой сразу за определением функции записать краткий комментарий, что эта функция делает, какие аргументы принимает, что возвращает.

Это нужно для того чтобы с вашим кодом было легче разбираться тем, кто будет его поддерживать/развивать после вас.

```py
def возведение_в_квадрат(параметр: int) -> int:
  """Функция возвращает квадрат переданного агрумента"""
  return параметр**2
```

Этот пример несколько утрирован, здесь название функции говорит само за себя, но в более сложных случаях документирование очень облегчает жизнь.

## Секреты хорошей функции (копипаст с хабра)

Что отличает «хорошую» функцию Python от посредственной? Вы удивитесь, как много трактовок допускает слово «хорошая». В рамках этой статьи я буду считать функцию Python «хорошей», если она удовлетворяет большинству пунктов из следующего списка (выполнить все пункты для конкретной функции порой невозможно):

* Она внятно названа
* Соответствует принципу единственной обязанности
* Содержит докстроку
* Возвращает значение
* Состоит не более чем из 50 строк
* Она идемпотентная и, если это возможно, чистая

Многим из вас эти требования могут показаться чрезмерно суровыми. Однако, обещаю: если ваши функции будут соответствовать этим правилам, то получатся настолько прекрасны, что пробьют на слезу даже единорога. Ниже я посвящу по разделу каждому из элементов вышеприведенного списка, а затем завершу повествование, рассказав, как они гармонируют друг с другом и помогают создавать хорошие функции.

### Именование

Вот моя любимая цитата на эту тему, часто ошибочно приписываемая Дональду, а на самом деле принадлежащая Филу Карлтону:

> В компьютерных науках есть две сложности: инвалидация кэша и именование.

Как бы глупо это ни звучало, именование – действительно сложная штука. Вот пример «плохого» названия функции:

```py
def get_knn_from_df(df):
```

Теперь плохие названия попадаются мне практически повсюду, но данный пример взят из области Data Science (точнее, машинного обучения), где практикующие специалисты обычно пишут код в блокноте Jupyter, а потом пытаются собрать из этих ячеек удобоваримую программу.

Первая проблема с названием этой функции – в нем используются аббревиатуры. Лучше использовать полные английские слова, а не аббревиатуры и не малоизвестные сокращения. Единственная причина, по которой хочется сокращать слова — не тратить сил на набор лишнего текста, но в любом современном редакторе есть функция автозавершения, поэтому вам придется набрать полное название функции всего один раз. Аббревиатура – это проблема,поскольку зачастую она специфична для предметной области. В вышеприведенном коде knn означает «K-ближайшие соседи», а df означает «DataFrame», структуру данных, повсеместно используемую в библиотеке pandas. Если код будет читать программист, не знающий этих сокращений, то он практически ничего не поймет в названии функции.

Еще в названии этой функции есть два более мелких недочета. Во-первых, слово "get" избыточно. В большинстве грамотно поименованных функций сразу понятно, что данная функция что-то возвращает, что конкретно – отражено в имени. Элемент from_df также не нужен. Либо в докстроке функции, либо (если она находится на периферии) в аннотации типа будет описан тип параметра, если эта информация и так не очевидна из названия параметра.

Так как же нам переименовать эту функцию? Просто:

```py
def k_nearest_neighbors(dataframe):
```

Теперь даже неспециалисту понятно, что вычисляется в этой функции, а имя параметра (dataframe) не оставляет сомнений, какой аргумент ей следует передавать.

### Единственная ответственность

Развивая мысль Боба Мартина, скажу, что Принцип единственной ответственности касается функций не меньше, чем классов и модулей (о которых изначально и писал господин Мартин). Согласно этому принципу (в нашем случае) у функции должна быть единственная ответственность. То есть, она должна делать одну и только одну вещь. Один из самых веских доводов в пользу этого: если функция делает всего одну вещь, то и переписывать ее придется в единственном случае: если эту самую вещь придется делать по-новому. Также становится ясно, когда функцию можно удалить; если, внеся изменения где-то в другом месте, мы поймем, что единственная обязанность функции более не актуальна, то мы от нее просто избавимся.

Здесь лучше привести пример. Вот функция, делающая более одной «вещи»:

```py
def calculate_and print_stats(list_of_numbers):
    sum = sum(list_of_numbers)
    mean = statistics.mean(list_of_numbers)
    median = statistics.median(list_of_numbers)
    mode = statistics.mode(list_of_numbers)

    print('-----------------Stats-----------------')
    print('SUM: {}'.format(sum)
    print('MEAN: {}'.format(mean)
    print('MEDIAN: {}'.format(median)
    print('MODE: {}'.format(mode)
```

А именно две: вычисляет набор статистических данных о списке чисел и выводит их в STDOUT. Функция нарушает правило: должна быть единственная конкретная причина, по которой ее, возможно, потребовалось бы изменить. В данном случае просматриваются две очевидные причины, по которым это понадобится: либо потребуется вычислять новую или иную статистику, либо потребуется изменить формат вывода. Поэтому данную функцию лучше переписать в виде двух отдельных функций: одна будет выполнять вычисления и возвращать их результаты, а другая – принимать эти результаты и выводить их в консоль. Функцию (вернее, наличие у нее двух обязанностей) с потрохами выдает слово and в ее названии.

Такое разделение также серьезно упрощает тестирование функции, а еще позволяет не только разбить ее на две функции в рамках одного и того же модуля, но даже разнести две эти функции в совершенно разные модули, если это уместно. Это дополнительно способствует более чистому тестированию и упрощает поддержку кода.

На самом деле, функции, выполняющие ровно две вещи, встречаются редко. Гораздо чаще натыкаешься на функции, делающие намного, намного больше операций. Опять же, из соображений удобочитаемости и тестируемости такие «многостаночные» функции следует дробить на однозадачные, в каждой из которых заключен единственный аспект работы.

### Докстроки

Казалось бы, все в курсе, что есть документ PEP-8, где даются рекомендации по стилю кода на Python, но гораздо меньше среди нас тех, кто знает PEP-257, в котором такие же рекомендации даются по поводу докстрок. Чтобы не пересказывать содержание PEP-257, отсылаю вас самих к этому документу – почитайте в свободное время. Однако, основные его идеи таковы:

* Для каждой функции нужна докстрока

* В ней следует соблюдать грамматику и пунктуацию; писать законченными предложениями
* Докстрока начинается с краткого (в одно предложение) описания того, что делает функция
* Докстрока формулируется в предписывающем, а не в описательном стиле

Все эти пункты легко соблюсти, когда пишешь функции. Просто написание докстрок должно войти в привычку, причем, старайтесь писать их прежде, чем приступать к коду самой функции. Если у вас не получается написать четкую докстроку, характеризующую функцию – это хороший повод задуматься, зачем вы вообще пишете эту функцию.

### Возвращаемые значения

Функции можно (и следует) трактовать как маленькие самодостаточные программы. Они принимают некоторый ввод в форме параметров и возвращают результат. Параметры, конечно, опциональны. А вот возвращаемые значения обязательны с точки зрения внутреннего устройства Python. Если вы даже попытаетесь написать функцию, которая не возвращает значения – не сможете. Если функция даже не станет возвращать значения, то интерпретатор Python «принудит» ее возвращать None.

Я даже не побоюсь утверждать следующее: каждая функция должна возвращать полезное значение, хотя бы ради тестируемости. Код, который я пишу, должен быть протестирован (это не обсуждается). Кроме того, возвращая значение, мы можем выполнять сцепление методов и, следовательно, писать код вот так:

```py
with open('foo.txt', 'r') as input_file:
    for line in input_file:
        if line.strip().lower().endswith('cat'):
            # ... делаем с этими строками что-нибудь полезное
```

Строка ``if line.strip().lower().endswith('cat'):`` работает, поскольку каждый из строковых методов (strip(), lower(), endswith()) в результате вызова функции возвращает строку.

Вот несколько распространенных доводов, которые вам может привести программист, объясняя, почему написанная им функция не возвращает значения:

> «Она всего лишь [какая-то операция, связанная с вводом/выводом, например, сохранение значения в базе данных]. Здесь я не могу вернуть ничего полезного.»

Не соглашусь. Функция может вернуть True, если операция завершилась успешно.

> «Здесь мы изменяем один из имеющихся параметров, используем его как ссылочный параметр.»

Здесь – два замечания. Во-первых, всеми силами старайтесь так не делать. Во-вторых, снабжать функцию каким-либо аргументом лишь для того, чтобы узнать, что она изменилась – в лучшем случае удивительно, а в худшем – попросту опасно. Вместо этого, как и при работе со строковыми методами, старайтесь возвращать новый экземпляр параметра, в котором уже отражены примененные к нему изменения. Даже если это не получается делать, поскольку создание копии какого-то параметра сопряжено с чрезмерными издержками, все равно можно откатываться к предложенному выше варианту «Вернуть True, если операция завершилась успешно».

> «Мне нужно возвращать несколько значений. Нет такого единственного значения,которое в данном случае было бы целесообразно возвращать.»

Этот аргумент немного надуманный, но мне доводилось его слышать. Ответ, разумеется, как раз в том, что автор и хотел сделать – но не знал как: для возврата нескольких значений используйте кортеж.

Наконец, самый сильный аргумент в пользу того, что полезное значение лучше возвращать в любом случае – в том, что вызывающая сторона всегда может с полным правом эти значения игнорировать. Короче говоря, возврат значения от функции – практически наверняка здравая идея, и крайне маловероятно, что мы таким образом что-нибудь повредим, даже в сложившихся базах кода.

### Длина функции

Я не раз признавался, что довольно туп. Могу одновременно держать в голове примерно три вещи. Если вы дадите мне прочесть 200-строчную функцию и спросите, что она делает, я, вероятно, буду таращиться на нее не менее 10 секунд. Длина функции прямо сказывается на ее удобочитаемости и, следовательно, на поддержке. Поэтому старайтесь, чтобы ваши функции оставались короткими. 50 строк – величина, взятая совершенно с потолка, но мне она кажется разумной. (Надеюсь), что большинство функций, которые вам доведется писать, будут значительно короче.

Если функция соответствует *Принципу единственной ответственности*, то, вероятно, она будет достаточно краткой. Если она чистая или идемпотентная (об этом мы поговорим) ниже – то, наверное, она также получится короткой. Все эти идеи гармонично сочетаются друг с другом и помогают писать хороший, чистый код.

Итак, что же делать, если ваша функция получилась слишком длинной? РЕФАКТОРИТЬ! Вероятно, вам приходится заниматься рефакторингом постоянно, даже если вы не знаете этого термина. Рефакторинг – это попросту изменение структуры программы, без изменения ее поведения. Поэтому, извлечение нескольких строк кода из длинной функции и превращение их в самостоятельную функцию – это один из типов рефакторинга. Оказывается, это еще и наиболее распространенный, и самый быстрый способ продуктивного укорачивания длинных функций. Поскольку вы даете этим новым функциям подходящие имена, получающийся у вас код гораздо проще читать. Я написал целую книгу о рефакторинге (на самом деле, я им постоянно занимаюсь), так что здесь вдаваться в детали не буду. Просто знайте, что, если у вас есть слишком длинная функция – то ее следует рефакторить.

### Идемпотентность и функциональная чистота

Заголовок этого раздела может показаться слегка устрашающим, но концептуально раздел прост. Идемпотентная функция при одинаковом наборе аргументов всегда возвращает одно и то же значение, независимо от того, сколько раз ее вызывают. Результат не зависит от нелокальных переменных, изменяемости аргументов или от любых данных, поступающих из потоков ввода/вывода. Следующая функция add_three(number) идемпотентна:

```py
def add_three(number):
    """вернуть *число* + 3."""
    return number + 3
```

Независимо от того, сколько раз мы вызовем add_three(7), ответ всегда будет равен 10. А вот другой случай – функция, не являющаяся идемпотентной:

```py
def add_three():
    """Вернуть 3 + число, введенное пользователем."""
    number = int(input('Enter a number: '))
    return number + 3
```

Эта откровенно надуманная функция не идемпотентна, поскольку возвращаемое значение функции зависит от ввода/вывода, а именно – от числа, введенного пользователем. Разумеется, при разных вызовах add_three() возвращаемые значения будут отличаться. Если мы дважды вызовем эту функцию, то пользователь в первом случае может ввести 3, а во втором – 7, и тогда два вызова add_three() вернут 6 и 10 соответственно.

Вне программирования также встречаются примеры идемпотентности – например, по такому принципу устроена кнопка «вверх» у лифта. Нажимая ее в первый раз,мы «уведомляем» лифт, что хотим подняться. Поскольку кнопка идемпотентна, то сколько ее потом ни нажимать – ничего страшного не произойдет. Результат будет всегда одинаков.

### Почему идемпотентность так важна

Тестируемость и удобство в поддержке. Идемпотентные функции легко тестировать, поскольку они гарантированно, в любом случае вернут одинаковый результат, если вызвать их с одними и теми же аргументами. Тестирование сводится к проверке того, что при разнообразных вызовах функция всегда возвращает ожидаемое значение. Более того, эти тесты будут быстрыми: скорость тестов – важная проблема, которую часто обходят вниманием при модульном тестировании. А рефакторинг при работе с идемпотентными функциями – вообще легкая прогулка. Не важно, как вы измените код вне функции – результат ее вызова с одними и теми же аргументами всегда будет один и тот же.

### Что такое «чистая» функция?

В функциональном программировании функция считается чистой, если она, во-первых, идемпотентна, а во-вторых – не вызывает наблюдаемых побочных эффектов. Не забывайте: функция идемпотентна, если всегда возвращает один и тот же результат при конкретном наборе аргументов. Однако, это не означает, что функция не может влиять на другие компоненты – например, на нелокальные переменные или потоки ввода/вывода. Например, если бы идемпотентная версия вышеприведенной функции add_three(number) выводила результат в консоль, а лишь затем возвращала бы его, она все равно считалась бы идемпотентной, поскольку при ее обращении к потоку ввода/вывода эта операция доступа никак не влияет на значение, возвращаемое от функции. Вызов print() – это просто побочный эффект: взаимодействие с остальной программой или системой как таковой, происходящее наряду с возвратом значения.

Давайте немного разовьем наш пример с add_three(number). Можно написать следующий код, чтобы определить, сколько раз была вызвана add_three(number):

```py
add_three_calls = 0

def add_three(number):
    """Вернуть *число* + 3."""
    global add_three_calls
    print(f'Returning {number + 3}')
    add_three_calls += 1
    return number + 3

def num_calls():
    """Вернуть, сколько раз была вызвана *add_three*."""
    return add_three_calls
```

Теперь мы выполняем вывод в консоль (это побочный эффект) и изменяем нелокальную переменную (другой побочный эффект), но, поскольку ни то, ни другое не влияет на значение, возвращаемое функцией, она все равно идемпотентна.

Чистая функция не оказывает побочных эффектов. Она не только не использует никаких «внешних данных» при расчете значения, но и не взаимодействует с остальной программой/системой, только вычисляет и возвращает указанное значение. Следовательно, хотя наше новое определение add_three(number) остается идемпотентным, эта функция уже не чистая.

В чистых функциях нет инструкций логирования или вызовов print(). При работе они не обращаются к базе данных и не используют соединений с интернетом. Не обращаются к нелокальным переменным и не изменяют их. И не вызывают других не-чистых функций.

Короче говоря, они не оказывают «жуткого дальнодействия», выражаясь словами Эйнштейна (но в контексте информатики, а не физики). Они не изменяют каким-либо образом остальные части программы или системы. В императивном программировании (а именно им вы и занимаетесь, когда пишете код на Python),такие функции – самые безопасные. Они известны своей тестируемостью и удобством в поддержке; более того, поскольку они идемпотентны, тестирование таких функций гарантированно будет столь же быстрым, как и выполнение. Сами тесты также просты: не приходится подключаться к базе данных либо имитировать какие-либо внешние ресурсы, готовить стартовую конфигурацию кода, а по окончании работы не нужно ничего подчищать.

Честно говоря, идемпотентность и чистота очень желательны, но не обязательны. То есть, нам бы хотелось писать только чистые или идемпотентные функции, учитывая все вышеупомянутые их преимущества, но это не всегда возможно. Суть, однако, в том, чтобы приучиться писать код, естественным образом не допуская побочных эффектов и внешних зависимостей. Таким образом, каждую написанную нами строку кода станет проще тестировать, даже если не удастся обойтись только лишь чистыми или идемпотентными функциями.

[содержание](/readme.md)  
