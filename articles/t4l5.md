# Тема 4. Работа с файлами</br>Лекция 5 Файлы произвольного доступа.

## Произвольный доступ
Открывать и закрывать файлы мы уже научились на прошлой лекции. Научились читать построчно и даже весь файл целиком. Но в реальной жизни чаще приходится работать двоичными файлами и их объем может превышать объем ОЗУ, например базы данных. И для таких файлов возникает необходимость постоянно перемещаться из одной части файла в другую (индексы баз данных).  

В этом случае нам поможет метод **seek**.

``seek(offset[, whence=0]->int``

* offset – смещение в байтах, может быть отрицательным (если смещение идет с середины файла или с конца);
* whence – указывает откуда брать смещение, с начала файла (0), с текущей позиции (1) или с конца файла (2).

Этот метод перемещает позицию чтения (или записи) в нужную нам сторону на нужное количество **байт**.

Возвращает новую позицию в файле.

Функция ``tell()->int`` возвращает текущую позицию файла.

## Бинарные файлы
Стандартный модуль *struct* позволяет преобразовывать объекты в структуры Си в виде строк в бинарном формате и обратно. Данные в строке располагаются в соответствии со строкой формата. Эти возможности могут быть использованы для чтения и сохранения в двоичном формате.

### Функции модуля struct:

``pack(format, value1, value2 ...)->bytes``</br>
Возвращает байтовую строку, содержащую значения value1, value2 ..., упакованные в соответствии с форматом. Количество и тип аргументов должны соответствовать значениям, которые требует строка формата format.

**Format** состоит из спецификаторов, определяющих как интерпретировать значение.

Спецификаторы, определяющие порядок, размер и Alignment байт

Спецификатор | Порядок | Размер | Alignment
:-----------:|---------|--------|----
@  | Native | native | native
=  | Native | standard | none
<  | little-endian | standard | none
\> | big-endian | standard | none
!  | network (big-endian) | standard | none

Если ни один из этих спецификаторов не задан, то по-умолчанию используется "@"

**Порядок** *native* - означает стандартный для текущей платформы (для intel это little-endian)

>Native byte order is big-endian or little-endian, depending on the host system. For example, Intel x86 and AMD64 (x86-64) are little-endian; Motorola 68000 and PowerPC G5 are big-endian; ARM and Intel Itanium feature switchable endianness (bi-endian). Use sys.byteorder to check the endianness of your system.

**Размер** может быть либо стандартным, либо в зависимости от настроек компилятора.



Спецификатор | тип (Си) | тип Питон | Стандартный размер
:-----------:|----------|---|---
цифра | количество повторений или длина | no value |  | 
с | char | bytes размером 1 байт | 1
b | знаковый байт | integer | 1
B | беззнаковый байт | integer | 1
? | логический | bool | 1
h | знаковое короткое | integer | 2
H | беззнаковое короткое | integer | 2
i | знаковое целое | integer | 4
I | беззнаковое целое | integer | 4
l | знаковое длинное | integer | 4
L | беззнаковое длинное | integer | 4
q | знаковое очень длинное | integer | 8
Q | беззнаковое очень длинное | integer | 8
e | single | float | 2
f | число с плавающей точкой | float | 4
d | число с плавающей точкой двойной точности | float | 8
p | char[] | bytes |
s | char[] | bytes | 
P | void*  | pointer | |

Как видим, спецификаторов больше чем типов в Питоне.

```py
from struct import *
# упаковываем три числа, два знаковых коротких и одно знаковое длинное
pack('hhl', 1, 2, 3)
# я выделил числа пробелами для наглядности, 
# на самом деле пробелов тут нет, конечно
>b'\x00\x01 \x00\x02 \x00\x00\x00\x03'
```

``unpack(format, buffer)->tuple``</br>
Распаковывает *buffer* в соответствии с форматом *format* и возвращает кортеж объектов.

Распаковываемы поля могут быть именованными (для использования с именованным кортежем).

```py
# исходная байтовая строка
record = b'raymond   \x32\x12\x08\x01\x08'
# распаковываем в кортеж: 10 смволов, два беззнаковых коротких и байт
name, serialnum, school, gradelevel = unpack('<10sHHb', record)

from collections import namedtuple
Student = namedtuple('Student', 'name serialnum school gradelevel')
Student._make(unpack('<10sHHb', record))
>Student(name=b'raymond   ', serialnum=4658, school=264, gradelevel=8)
```

``calcsize(format)->int``</br>
Возвращает размер структуры (т.е. длину результирующей байтовой строки), соответствующей формату format.

Перед символом формата может идти число, обозначающее количество повторений. Например, строка формата '4h' полностью эквивалентна строке 'hhhh'. 

>тут не понял: Символы пропуска между символами формата игнорируются, однако символы пропуска между числом и символом формата не допускаются.

Число перед символом формата 's' интерпретируется как длина строки, а не число повторений. То есть '10s' обозначает строку из 10 символов, в то время как '10c' – 10 раз по одному символу.

В следующем примере мы упаковываем в структуру два числа – целое и float, строку из пяти символов, сохраняем в бинарный файл, а потом извлекаем из файла:

```py
from struct import *

out = open("123.bin", "wb")    
data   = pack("if5s", 24,12.48,'12345')
out.write(data)
out.close()

input = open("123.bin", "rb")
data = input.read()
input.close()

format = "if5s" 
value,value2,value3 = unpack(format, data) 

print value
print value2
print value3
print calcsize(format)
 
>24
>12.4799995422
>12345
>13
```

The ordering of format characters may have an impact on size since the padding needed to satisfy alignment requirements is different (порядок символов формата может повлиять на размер структуры). Вроде такое возможно с нативными типами, поэтому лучше работать со стандартом (проверить на практике).

```py
pack('ci', b'*', 0x12131415)
>b'*\x00\x00\x00\x12\x13\x14\x15'
pack('ic', 0x12131415, b'*')
>b'\x12\x13\x14\x15*'
calcsize('ci')
>8
calcsize('ic')
>5
```

``struct.iter_unpack(format, buffer)->iterable``
Возвращает итерабельный объект, из которого в цикле можно доставать однотипные структуры.

>Проверить на практике

Модуль *struct* содержит также классы для упаковки/распаковки данных. Они выполняют те же действия и с ними вы сможете самостоятельно разобраться, когда мы изучим ООП.

## Пример чтения двоичного файла
Попробуем на практике прочитать заголовок файла формата *.wav*.

### Теория
Итак, рассмотрим самый обычный WAV файл (Windows PCM). Он представляет собой две, четко делящиеся, области. Одна из них – заголовок файла, другая – область данных. 

В заголовке файла хранится информация о:
* Размере файла.
* Количестве каналов.
* Частоте дискретизации.
* Количестве бит в сэмпле (эту величину еще называют глубиной звучания).

Структура заголовка:

Местоположение   | Поле          | Описание
-----------------|---------------|---------
0..3 (4 байта)   | chunkId       | Содержит символы “RIFF” в ASCII кодировке
4..7 (4 байта)   | chunkSize     | Размер файла -8 (т.е. минус два поля, которые уже считаны)
8..11 (4 байта)  | format        | Содержит символы “WAVE”
12..15 (4 байта) | subchunk1Id   | Содержит символы “fmt “ (0x666d7420 в big-endian представлении)
16..19 (4 байта) | subchunk1Size | 16 для формата PCM. Это оставшийся размер подцепочки, начиная с этой позиции.
20..21 (2 байта) | audioFormat   | Аудио формат, для PCM = 1 (то есть, Линейное квантование). Значения, отличающиеся от 1, обозначают некоторый формат сжатия.
22..23 (2 байта) | numChannels   | Количество каналов. Моно = 1, Стерео = 2 и т.д.
24..27 (4 байта) | sampleRate    | Частота дискретизации. 8000 Гц, 44100 Гц и т.д.
28..31 (4 байта) | byteRate      | Количество байт, передаваемых за секунду воспроизведения.
32..33 (2 байта) | blockAlign    | Количество байт для одного сэмпла, включая все каналы.
34..35 (2 байта) | bitsPerSample | Количество бит в сэмпле. Так называемая “глубина” или точность звучания. 8 бит, 16 бит и т.д.
36..39 (4 байта) | subchunk2Id   | Содержит символы “data” (0x64617461 в big-endian представлении)
40..43 (4 байта) | subchunk2Size | Количество байт в области данных.

Дальше идут собственно данные.

Пример программы чтения заголовка файла WAV.

```py
from struct import unpack
import os

name = "pluck-pcm8.wav"

# проверяем что такой файл есть и он достаточной длины
if os.path.isfile(name) and os.path.getsize(name)>43:
  # открываем на чтение в двоичном режиме
  with open(name, "rb") as wav_file:
    # считываем 44 байта
    header = wav_file.read(44)
    # распаковываем заголовок
    (riff,file_size,wave,fmt,chunk_size,audio_format,channels,\
          sample_rate,byte_rate,block_align,bps,data,data_size) = \
          unpack('4sI4s4sIHHIIHH4sI', header)
    # проверяем соответствие формату
    if riff==b'RIFF' and wave==b'WAVE' and fmt==b'fmt ':
      print('Размер файла: %d' % (file_size+8))
      print('Аудиоформат: %s' % 'PCM' if audio_format==1 else 'сжатый')
      print('Количество каналов: %d' % channels)
      print('Частота дискретизации: %dГц' % sample_rate)
      print('Битрейт: %d байт/сек' % byte_rate)
      print('Размер блока: %d байт' % block_align)
      print('Глубина заучания (BPS): %d бит' % bps)
      print('Размер блока данных: %d байт' % data_size)
    else:
      print('файл не содержит заголовка WAV')  
else:
  print('файла %s нет или он недостаточной длины для WAV' % name)
```

Получим примерно такой результат:
```
Размер файла: 6756
Аудиоформат: PCM
Количество каналов: 2
Частота дискретизации: 11025Гц
Битрейт: 22050 байт/сек
Размер блока: 2 байт
Глубина заучания (BPS): 8 бит
```

Теперь для считывания данных, например, с середины, мы можем рассчитать смещение для функции *seek*

```py
samples_count = ((file_size+8) - 44) // block_align
seek(44 + samples_count//2, 0)
```
