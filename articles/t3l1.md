# Программирование на языках Pascal, Python</br>Лекции 1 и 2
* Основные элементы языка. 
* Структурная схема программы на алгоритмическом языке. 
* Лексика языка. 
* Переменные и константы. 
* Типы данных. 
* Выражения и операции.
* Операторы и операции языка.
* Синтаксис операторов.
* Составной оператор.
* Вложенные условные операторы.

## Основные свойства
Python не требует явного объявления переменных, является регистро-зависимым (переменная var не эквивалентна переменной Var или VAR — это три разные переменные)объектно-ориентированным языком.

В питоне нет констант (обычно переменные, которые не предполагается менять, пишут большими буквами)

## Алфавит
В именах переменных и функций допускаются латинские буквы, цифры и знак подчеркивания.

## Структура Python-программ
### Лексическая структура
Любая Python-программа состоит из последовательности лексем (допустимых символов), записанных в определенном порядке и по определенным правилам.

Лексемы включают в себя:
* комментарии;
* литералы;
* знаки пунктуации;
* идентификаторы;
* ключевые слова.

#### Комментарии
Комментарии предназначены для пояснения кода для разработчика (Python их пропускает) и начинаются с символа #, действуя до конца строки (Листинг 2.1.1).
```python
# Вся эта строка является комментарием
x = 5  # Это inline-комментарий (отступ 2 пробела)
y = '#Это строка'  # А это комментарий
```
Комментарии должны объяснять, почему что-то реализовано именно так и объяснять:
* предположения, важные решения, важные детали;
* проблемы, которые решает код;
* проблемы, которых необходимо избежать и т.д.

#### Литералы
Литералы - значения, представленные в коде программы, например, числа или строки 
```python
5         # Целочисленный литерал
3.4       # Литерал в виде числа с плавающей точкой
'строка'  # Строковый литерал
```

#### Знаки пунктуации
В алфавит Python входит достаточное количество знаков пунктуации, которые используются для различных целей. Например, знаки + или * могут использоваться для сложения и умножения, а знак запятой , - для разделения параметров функций.

#### Идентификаторы
Идентификатор - обычное имя, которое дается ссылке на какой-либо объект. Любой идентификатор имеет некоторые правила и соглашения наименования:
* может состоять из букв (ASCII или Unicode), знаков подчеркивания _ или цифр 0-9;
* цифра не может быть на первом месте;
* чувствителен к регистру: UserName, username и USERNAME - разные идентификаторы;
* не должен совпадать с каким-либо из ключевых слов языка Python

**соглашения:**
* использовать змеиный_регистр (англ. snake_case): customer_account;
* не использовать предопределенные имена;
* не использовать 2 знака подчеркивания __ в начале и конце, и _ или __ в начале идентификатора; данный синтаксис имеет специальное назначение.

## Ключевые (зарезервированные) слова
Имена переменным придумывает программист, но есть несколько ограничений,
связанных с наименованием. В качестве имен переменных нельзя использовать ключевые
слова, которые для Python имеют определенный смысл (эти слова обычно подсвечиваются в IDE цветом):

|  |  |  | | | | 
----|----|--------|-------|-------|--------
and | as | assert | break | class | continue
def | del | elif | else | except |
finally | for | from | global | if | import
in | is | lambda | nonlocal | not | or
pass | raise | return | try | while | with
yield | True | False | None

## Синтаксис
* Во первых стоит отметить интересную особенность Python. Он не содержит операторных скобок (begin..end в pascal или {..}в Си), вместо этого блоки выделяются отступами: пробелами или табуляцией, а вход в блок из операторов осуществляется двоеточием. 

```python
if(x>0):
    x=0
    y=0
    z=0
else:
    x=y=z=1
```
* Конец строки является концом инструкции (точка с запятой не требуется).

* Однострочные комментарии начинаются со знака фунта «#», многострочные — начинаются и заканчиваются тремя двойными кавычками «"""».

```python
# однострочный комментарий
"""это тоже комментарий
и его можно писать в несколько
строк"""
```

* Вложенные инструкции объединяются в блоки по величине отступов. Отступ может быть любым, главное, чтобы в пределах одного вложенного блока отступ был одинаков. И про читаемость кода не забывайте. Отступ в 1 пробел, к примеру, не лучшее решение. Используйте 4 пробела (или знак табуляции, на худой конец).

* Вложенные инструкции в Python записываются в соответствии с одним и тем же шаблоном, когда основная инструкция завершается двоеточием, вслед за которым располагается вложенный блок кода, обычно с отступом под строкой основной инструкции.

```python
Основная инструкция:
    Вложенный блок инструкций:
        Еще один уровень 
```

Чтобы присвоить значение пременной используется знак «=», а для сравнения — 
«==». Для увеличения значения переменной, или добавления к строке используется оператор «+=», а для уменьшения — «-=». Все эти операции могут взаимодействовать с большинством типов, в том числе со строками. Например:

```python
myvar = 3
myvar += 2
myvar -= 1
mystring = "Hello"
mystring += " world."
print(mystring)
>Hello world.
# Следующая строка меняет значения переменных местами. (Всего одна строка!)
myvar, mystring = mystring, myvar
```

## Несколько специальных случаев
* Иногда возможно записать несколько инструкций в одной строке, разделяя их точкой с запятой:

```python
a = 1; b = 2; print(a, b)
```

* Допустимо записывать одну инструкцию в нескольких строках. Достаточно ее заключить в пару круглых, квадратных или фигурных скобок, либо с использованием висячего отступа. При использовании висячего отступа следует применять следующие соображения: на первой линии не должно быть аргументов, а остальные строки должны четко восприниматься как продолжение линии.

```python
# выражение заключено в скобки и выровнено по открывающей скобке
if (a == 1 and b == 2 and
    c == 3 and d == 4):  # Не забываем про двоеточие
        print('spam' * 3)

# Выровнено по открывающему разделителю
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# Больше отступов включено для отличения его последующего блока
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)                         

```

* Тело составной инструкции может располагаться в той же строке, что и тело основной, если тело составной инструкции не содержит составных инструкций.

```python
if x > y: print(x)
```

* Для склейки строк можно использовать обратную косую черту. Например, длинная конструкция with не может использовать неявные продолжения, так что обратная косая черта является приемлемой:

```python
with open('/path/to/some/file/you/want/to/read') as file_1, \
        open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
```

## Пустые строки
* Отделяйте функции верхнего уровня и определения классов двумя пустыми строками.
* Определения методов внутри класса разделяются одной пустой строкой.

```python
from MainWindow import Ui_MainWindow


class MainWindow(QMainWindow, Ui_MainWindow):
    def __init__(self, *args, **kwargs):
      pass

    def other(self):
      pass  
```

## Операторы
В языке Python поддерживает такие типы операторов:
* арифметические операторы
* операторы сравнения
* операторы присваивания
* логические операторы
* битовые операторы
* операторы принадлежности
* операторы тождественности

Далее мы рассмотрим все эти операторы по очереди.

**Арифметические операторы**  
Предположим, переменная a = 10, а переменная b = 20.

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
\+ | сложение  | a + b = 30
 – | вычитание | a – b = -10
\* | умножение | a * b = 200
\/ | деление   | b / a = 2
% | модуль (остаток целочисленного деления) | b % a = 0
\*\*      | возведение в степень | a\*\*b = 10<sup>20</sup>
 \/\/      | целочисленное деление | 9\/\/2 = 4

**Операторы сравнения**
Результатом сравнения будет логическое значение *True* или *False*

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
= | истинным | 5 = 5 в результате будет True
== | Проверяет равны ли оба операнда.</br>Если да, то условие становится истинным | 5 == 5 в результате будет *True*</br>*True* == *False* в результате будет *False*</br>"hello" == "hello" в результате будет *True*
!= | Проверяет равны ли оба операнда.</br>Если нет, то условие становится истинным | 12 != 5 в результате будет *True*</br>*False* != *False* в результате будет *False*</br>"hi" != "Hi" в результате будет *True*
 <> | Проверяет равны ли оба операнда.</br>Если нет, то условие становится истинным | 12 <> 5 в результате будет True</br>Похоже на оператор !=
 \> | Проверяет больше ли значение левого операнда,</br>чем значение правого. Если да, то условие становится истинным | 5 > 2 в результате будет True</br>True > False в результате будет True</br>"A" > "B" в результате будет False.
 < | Проверяет меньше ли значение левого операнда,</br>чем значение правого.</br>Если да, то условие становится истинным | 3 < 5 в результате будет True</br>True < False в результате будет False</br>"A" < "B" в результате будет True.
 \>= | Проверяет больше или равно значение левого операнда,</br>чем значение правого.</br>Если да, то условие становится истинным | 1 >= 1 в результате будет True</br>23 >= 3.2 в результате будет True</br>"C" >= "D" в результате будет False.
 <= | Проверяет меньше или равно значение левого операнда,</br>чем значение правого.</br>Если да, то условие становится истинным | 4 <= 5 в результате будет True</br>0 <= 0.0 в результате будет True</br>-0.001 <= -36 в результате будет False

**Операторы присваивания**  
Присваивает значение правого **выражения** левому операнду

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
 = | Присваивает значение правого операнда левому. | c = 23 присвоит переменной с значение 23
 += | Прибавит значение правого операнда к левому</br>и присвоит эту сумму левому операнду | с = 5</br>а = 2</br>с += а равносильно: с = с + а</br>с будет равно 7
 -= | Отнимает значение правого операнда от левого</br>и присваивает результат левому операнду | с = 5</br>а = 2</br>с -= а равносильно: с = с - а</br>с будет равно 3
 *= | Умножает правый операнд с левым</br>и присваивает результат левому операнду | с = 5</br>а = 2</br>с *= а равносильно: с = с * а</br>c будет равно 10
 /= | Делит левый операнд на правый</br>и присваивает результат левому операнду | с = 10</br>а = 2</br>с /= а равносильно: с = с / а</br>c будет равно 5
 %= | Делит по модулю операнды</br> и присваивает результат левому | с = 5</br>а = 2</br>с %= а равносильно: с = с % а</br>c будет равно 1
 \*\*= | Возводит левый операнд в степень правого</br>и присваивает результат левому операнду | с = 3</br>а = 2</br>с \*\*= а равносильно: с = с \*\* а.</br>c будет равно 9
 //= | Производит целочисленное деление левого операнда на правый</br>и присваивает результат левому операнду | с = 11</br>а = 2</br>с //= а равносильно: с = с // а</br>c будет равно 5

**Побитовые операторы**  
Побитовые операторы предназначены для работы с данными в битовом (двоичном) формате. Предположим, что у нас есть два числа a = 60; и b = 13. В двоичном формате они будут иметь следующий вид:  
a = 0011 1100  
b = 0000 1101

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
& | Бинарный "И" | a & b = 12, которое в двоичном формате выглядит так 0000 1100
\| | Бинарный "ИЛИ" | a \| b = 61 (0011 1101)
^ | Бинарный "Исключительное ИЛИ" | a ^ b = 49 (0011 0001)
~ | Бинарный комплиментарный оператор</br>Является унарным (то есть ему нужен только один операнд) | ~a = -61 (1100 0011)
<< | Побитовый сдвиг влево</br>Значение левого операнда "сдвигается" влево на количество бит указанных в правом операнде | a << 2 = 240 (1111 0000)
\>> | Побитовый сдвиг вправо</br>Значение левого операнда "сдвигается" вправо на количество бит указанных в правом операнде | a >> 2 = 15 (0000 1111)

**Логические операторы**

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
and | Логический оператор "И"</br>Условие будет истинным если оба операнда истина | True and True равно True</br>True and False равно False</br>False and True равно False</br>False and False равно False
or | Логический оператор "ИЛИ"</br>Если хотя бы один из операндов истинный, то и все выражение будет истинным. | True or True равно True</br>True or False равно True</br>False or True равно True</br>False or False равно False
not | Логический оператор "НЕ"</br>Изменяет логическое значение операнда на противоположное | not True равно False</br>not False равно True

**Операторы членства**  
В Python присутствуют, так называмые, операторы членства, предназначенные для проверки на наличие элемента в составных типах данных, таких, как строки, списки, кортежи или словари:

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
in | Возвращает истину, если элемент присутствует в последовательности, иначе возвращает ложь | "cad" in "cadillac" вернет True</br>1 in [2,3,1,6] вернет True</br>"hi" in {"hi":2,"bye":1} вернет True</br>2 in {"hi":2,"bye":1} вернет False</br>(в словарях проверяется наличие в ключах, а не в значениях)
not in | Возвращает истину если элемента нет в последовательности | Результаты противоположны результатам оператора in.

**Операторы тождественности**  
Операторы тождественности сравнивают размещение двух объектов в памяти компьютера.

ОПЕРАТОР | ОПИСАНИЕ  | ПРИМЕР
:-------:|-----------|-------
is | Возвращает истину, если оба операнда указывают на один объект | x is y вернет истину, если id(x) будет равно id(y).
is not | Возврашает ложь если оба операнда указывают на один объект | x is not y, вернет истину если id(x) не равно id(y).

**Приоритет операторов**  
В следующей таблице описан приоритет выполнения операторов в Python от наивысшего (выполняется в первую очередь) до наинизшего.

ОПЕРАТОР | ОПИСАНИЕ 
:-------:|----------
** | Возведение в степень
~ | Комплиментарный оператор
*</br>/</br>%</br>// | Умножение</br>деление</br>деление по модулю</br>целочисленное деление
+</br>- | Сложение</br>вычитание
\>></br><< | Побитовый сдвиг вправо</br>побитовый сдвиг влево.
& | Бинарный "И"
^</br>\| | Бинарный "Исключительное ИЛИ"</br>бинарный "ИЛИ"
<=</br><</br>></br>>= | Операторы сравнения
<></br>==</br>!= | Операторы равенства (неравенства)
=</br>%=</br>/=</br>//=</br>-=</br>+=</br>*=</br>**= | Операторы присваивания
is</br>is not | Тождественные операторы
in</br>not in | Операторы членства
not</br>or</br>and | Логические операторы

В случае сомнений в порядке вычислений будет не лишним обозначить приоритет в
виде круглых скобок. 

## Типы данных и операции с ними
### Числа: целые, вещественные, комплексные
**Целые числа (int)**  
Числа в Python ничем не отличаются от обычных чисел. Они поддерживают набор самых обычных математических операций:

 Операция | Описание
------|---------
x + y	| Сложение  
x - y |	Вычитание  
x * y	| Умножение  
x / y	| Деление  
x // y | Получение целой части от деления  
x % y	| Остаток от деления  
-x | Смена знака числа  
abs(x) | Модуль числа  
divmod(x, y) | Пара (x // y, x % y)
x ** y | Возведение в степень
pow(x, y[, z]) | x<sup>y</sup> по модулю (если модуль задан)

Также нужно отметить, что целые числа в python 3, в отличие от многих других языков,поддерживают длинную арифметику (однако, это требует больше памяти)

Над целыми числами также можно производить битовые операции

 Операция | Описание
------|---------
x \| y | Побитовое или
x ^ y	| Побитовое исключающее или
x & y	| Побитовое и
x << n | Битовый сдвиг влево
x >> y | Битовый сдвиг вправо
~x | Инверсия битов

**Системы счисления**
Те, у кого в школе была информатика, знают, что числа могут быть представлены не только в десятичной системе счисления. К примеру, в компьютере используется двоичный код, и, к примеру, число 19 в двоичной системе счисления будет выглядеть как 10011. Также иногда нужно переводить числа из одной системы счисления в другую. Python для этого предоставляет несколько функций:

* int([object], [основание системы счисления]) - преобразование к целому числу в десятичной системе счисления. По умолчанию система счисления десятичная, но можно задать любое основание от 2 до 36 включительно.
* bin(x) - преобразование целого числа в двоичную строку.
* hex(х) - преобразование целого числа в шестнадцатеричную строку.
* oct(х) - преобразование целого числа в восьмеричную строку.

Примеры:
```python
a = int('19') # Переводим строку в число
b = int('19.5')  # Строка не является целым числом
Traceback (most recent call last):
  File "", line 1, in
ValueError: invalid literal for int() with base 10: '19.5'

c = int(19.5)  # Применённая к числу с плавающей точкой, отсекает дробную часть
print(a, c)
19 19

bin(19)
'0b10011'

oct(19)
'0o23'

hex(19)
'0x13'

0b10011  # Так тоже можно записывать числовые константы
19

int('10011', 2)
19

int('0b10011', 2)
19
```

**Вещественные числа (float)**  
Вещественные числа поддерживают те же операции, что и целые. Однако (из-за представления чисел в компьютере) вещественные числа неточны, и это может привести к ошибкам:
```python
0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1
0.9999999999999999
```
Для высокой точности используют другие объекты (например Decimal и Fraction)).

Также вещественные числа не поддерживают длинную арифметику.

Помимо стандартных выражений для работы с числами (а в Python их не так уж и много), в составе Python есть несколько полезных модулей.

Модуль **math** предоставляет более сложные математические функции.

Модуль **random** реализует генератор случайных чисел и функции случайного выбора.

**Комплексные числа (complex)**
В Python встроены также и комплексные числа:
```python
x = complex(1, 2)
print(x)
>(1+2j)
```

### Строки
Строки в Python - упорядоченные последовательности символов, используемые для хранения и представления текстовой информации, поэтому с помощью строк можно работать со всем, что может быть представлено в текстовой форме.

**Литералы строк**
Работа со строками в Python очень удобна. Существует несколько литералов строк, которые мы сейчас и рассмотрим.
```python
#Строки в апострофах и в кавычках
S = 'spam"s'
S = "spam's"
```
Строки в апострофах и в кавычках - одно и то же. Причина наличия двух вариантов в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов, не используя экранирование.

**Экранированные последовательности - служебные символы**
Экранированные последовательности позволяют вставить символы, которые сложно ввести с клавиатуры.

Экранированная последовательность | Назначение
:--------------------------------:|-----------
\n | Перевод строки
\a | Звонок
\b | Забой
\f | Перевод страницы
\r | Возврат каретки
\t | Горизонтальная табуляция
\v | Вертикальная табуляция
\N{id} | Идентификатор ID базы данных Юникода
\uhhhh | 16-битовый символ Юникода в 16-ричном представлении
\Uhhhh… | 32-битовый символ Юникода в 32-ричном представлении
\xhh | 16-ричное значение символа
\ooo | 8-ричное значение символа
\0 | Символ Null (не является признаком конца строки)

**"Сырые" строки - подавляют экранирование**
Если перед открывающей кавычкой стоит символ 'r' в любом регистре (скорее всего это сокращение от RAW), то механизм экранирования отключается.
```python
S = r'C:\newt.txt'
```

Но, несмотря на назначение, "сырая" строка не может заканчиваться символом обратного слэша. Пути решения:
```python
S = r'\n\n\\'[:-1]
S = r'\n\n' + '\\'
S = '\\n\\n'
```

**Строки в тройных апострофах или кавычках**
Главное достоинство строк в тройных кавычках в том, что их можно использовать для записи многострочных блоков текста. Внутри такой строки возможно присутствие кавычек и апострофов, главное, чтобы не было трех кавычек подряд.

```python
c = '''это очень большая
строка, многострочный
блок текста'''
```

**Базовые операции со строками**
* Конкатенация (сложение)
```python
S1 = 'spam'
S2 = 'eggs'
print(S1 + S2)
>spameggs
```

* Дублирование (клонирование) строки
```python
print('spam' * 3)
>spamspamspam
```

* Длина строки (функция len)
```python
len('spam')
>4
```

* Доступ по индексу
```python
S = 'spam'
S[0] 
's'
S[2]
'a'
S[-2]
'a'
```

Как видно из примера, в Python возможен и доступ по отрицательному индексу, при этом отсчет идет от конца строки.

* Извлечение среза (части строки)

Оператор извлечения среза: [X:Y]. X – начало среза, а Y – окончание;

символ с номером Y в срез не входит. По умолчанию первый индекс равен 0, а второй - длине строки.

```python
s = 'spameggs'
s[3:5]
'me'
s[2:-2]
'ameg'
s[:6]
'spameg'
s[1:]
'pameggs'
s[:]
'spameggs'
```

Кроме того, можно задать шаг, с которым нужно извлекать срез.
```python
s[::-1]
'sggemaps'
s[3:5:-1]
''
s[2::2]
'aeg'
```

**Другие функции и методы строк**
При вызове методов необходимо помнить, что строки в Python относятся к категории неизменяемых последовательностей, то есть все функции и методы могут лишь создавать новую строку.

Поэтому все строковые методы возвращают новую строку, которую потом следует присвоить переменной.

Функция или метод	| Назначение
----|----
S = 'str'</br>S = "str"</br>S = '''str'''</br>S = """str""" |Литералы строк
S = "s\np\ta\nbbb" | Экранированные последовательности
S = r"C:\temp\new" | Неформатированные строки (подавляют экранирование)
S = b"byte"	| Строка байтов
S1 + S2	| Конкатенация (сложение строк)
S1 * 3 | Повторение строки
S[i] | Обращение по индексу
S[i:j:step] | Извлечение среза

Иногда (а точнее, довольно часто) возникают ситуации, когда нужно сделать строку, подставив в неё некоторые данные, полученные в процессе выполнения программы (пользовательский ввод, данные из файлов и т. д.). Подстановку данных можно сделать с помощью форматирования строк. Форматирование можно сделать с помощью оператора %, либо с помощью метода format.

**Форматирование строк с помощью метода format**
Если для подстановки требуется только один аргумент, то значение - сам аргумент:
```python
'Hello, {}!'.format('Vasya')
'Hello, Vasya!'
```

А если несколько, то значениями будут являться все аргументы со строками подстановки (обычных или именованных):
```python
'{0}, {1}, {2}'.format('a', 'b', 'c')
'a, b, c'
'{}, {}, {}'.format('a', 'b', 'c')
'a, b, c'
```

Однако метод format умеет большее. Полный синтаксис выходит за рамки лекции.

>TODO: сюда перенести encode/decode из пятой лекции

<a name="list"></a>

### Списки
Списки в Python - упорядоченные **изменяемые** коллекции объектов произвольных типов (почти как массив, но типы могут отличаться).

Чтобы использовать списки, их нужно создать. Создать список можно несколькими способами. Например, можно обработать любой итерируемый объект (например, строку) встроенной функцией list:
```python
list('список')
['с', 'п', 'и', 'с', 'о', 'к']
```

Список можно создать и при помощи литерала:
```python
s = []  # Пустой список
l = ['s', 'p', ['isok'], 2]
```

Как видно из примера, список может содержать любое количество любых объектов (в том числе и вложенные списки), или не содержать ничего.

И еще один способ создать список - это **генераторы списков**. Генератор списков - способ построить новый список, применяя выражение к каждому элементу последовательности. Генераторы списков очень похожи на цикл for.
```python
c = [c * 3 for c in 'list']
['lll', 'iii', 'sss', 'ttt']
```

т.е. для каждой буквы из слова 'list' выполнить тройное клонирование

Возможна и более сложная конструкция генератора списков:
```python
c = [c * 3 for c in 'list' if c != 'i']
['lll', 'sss', 'ttt']
```
то же самое, но с условием.

Нужно отметить, что методы списков, в отличие от строковых методов, изменяют сам список, а потому результат выполнения не нужно записывать в эту переменную.
```python
l = [1, 3, 2, 5, 7]
l.sort()
[1, 2, 3, 5, 7]
```

### Кортежи (tuple)

Кортеж, по сути - неизменяемый список.

Зачем нужны кортежи, если есть списки?

* Защита от дурака. То есть кортеж защищен от изменений, как намеренных (что плохо), так и случайных (что хорошо).
* Меньший размер в памяти.
* Возможность использовать кортежи в качестве ключей словаря:

**Как работать с кортежами?**  
С преимуществами кортежей разобрались, теперь встает вопрос - а как с ними работать. Примерно так же, как и со списками.

Создаем пустой кортеж:
```python
a = tuple() # С помощью встроенной функции tuple()
()
a = () # С помощью литерала кортежа
()
```

Создаем кортеж из одного элемента:
```python
a = ('s')
's'
```

Стоп. Получилась строка. Но как же так? Мы же кортеж хотели! Как же нам кортеж получить?

```python
a = ('s', )
('s',)

a = 's',
```

Cоздать кортеж из итерируемого объекта можно с помощью все той же пресловутой функции tuple()
```python
a = tuple('hello, world!')
('h', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!')
```

**Операции с кортежами**  
Все операции над списками, не изменяющие список (сложение, умножение на число, методы index() и count() и некоторые другие операции). Можно также по-разному менять элементы местами и так далее.

Например, гордость программистов на python - поменять местами значения двух переменных:
```
a, b = b, a
```

### Словари
Словари в Python - неупорядоченные коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.

Чтобы работать со словарём, его нужно создать. Создать его можно несколькими способами. Во-первых, с помощью литерала:
```python
d = {}
{}

d = {'dict': 1, 'dictionary': 2}
{'dict': 1, 'dictionary': 2}
```

Во-вторых, с помощью функции dict:
```python
d = dict(short='dict', long='dictionary')
{'short': 'dict', 'long': 'dictionary'}

d = dict([(1, 1), (2, 4)])
{1: 1, 2: 4}
```

В-третьих, с помощью метода fromkeys:
```python
d = dict.fromkeys(['a', 'b'])
{'a': None, 'b': None}

d = dict.fromkeys(['a', 'b'], 100)
{'a': 100, 'b': 100}
```

В-четвертых, с помощью генераторов словарей, которые очень похожи на генераторы списков.
```python
d = {a: a ** 2 for a in range(7)}
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
```

Теперь попробуем добавить записей в словарь и извлечь значения ключей:
```python
d = {1: 2, 2: 4, 3: 9}
d[1]
2

d[4] = 4 ** 2
{1: 2, 2: 4, 3: 9, 4: 16}

d['1']
error
```

Как видно из примера, присвоение по новому ключу расширяет словарь, присвоение по существующему ключу перезаписывает его, а попытка извлечения несуществующего ключа порождает исключение. Для избежания исключения есть специальный метод (см. ниже), или можно перехватывать исключение.

Что же можно еще делать со словарями? Да то же самое, что и с другими объектами: встроенные функции, ключевые слова (например, циклы for и while), а также специальные методы словарей.

### Множество
Множество в python - "контейнер", содержащий не повторяющиеся элементы в случайном порядке.

Создаём множества:
```python
a = set()
set()

a = set('hello')
{'h', 'o', 'l', 'e'}

a = {'a', 'b', 'c', 'd'}
{'b', 'c', 'a', 'd'}

a = {i ** 2 for i in range(10)} # генератор множеств
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}

a = {}  # А так нельзя!
```
Как видно из примера, множества имеет тот же литерал, что и словарь, но пустое множество с помощью литерала создать нельзя.

Множества удобно использовать для удаления повторяющихся элементов:
```python
words = ['hello', 'daddy', 'hello', 'mum']
set(words)
{'hello', 'daddy', 'mum'}
```

### frozenset
Единственное отличие frozenset от set заключается в том, что set - изменяемый тип данных, а frozenset - нет. Примерно похожая ситуация с списками и кортежами.


## Составные элементы Python-программы
Python относится к языкам, разделяющим идею методологии структурного программирования, в основе которой лежит представление программы в виде иерархической структуры блоков.

Блоки в свою очередь могут состоять из элементов или из таких же блоков. Блоки, выделяемые в Python, представлены ниже

Наименование блока | Описание
-------------------|----------
Последовательность (инструкция) | Любое атомарное действие, например, присваивание
Ветвление (условие) | Выполнение инструкций в зависимости от определенного условия
Цикл | Многократное исполнение набора инструкций
Подпрограмма (процедура/функция) | Часть компьютерной программы, содержащая описание определенного набора инструкций, которая может быть многократно вызвана из разных частей программы.
Класс	| Абстрактный тип данных в объектно-ориентированном программировании, задающий общее поведение для группы объектов; модель объекта.
Модуль | Функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом или поименованной непрерывной ее части.
Пакет	| Логически законченная совокупность модулей как единое целое

## Структура файла и кодировка программы
Программный код на языке Python можно записать в любом простом текстовом редакторе,который способен загружать и сохранять текст в кодировке UTF-8. По умолчанию предполагается, что файлы с программным кодом на языке Python сохраняются в кодировке UTF-8 - надмножестве кодировки ASCII, с помощью которой можно представить практически любой символ любого национального алфавита. Файлы с программным кодом на языке Python обычно имеют расширение *.ру

В начале файла также допускается, но не рекомендуется указывать отдельной строкой кодировку отличную от UTF-8, например # coding: cp-1251.

Не рекомендуется также делать размер строки кода больше 80 символов (такую программу удобно просматривать и при необходимости распечатать - в большинстве редакторов для этого специально предусмотрена визуальная вертикальная полоса). Если строка все же не умещается в это ограничение, необходимо выполнить перенос строки
```python
# Для переноса строки используется обратный слеш \
# Это указывает на явный перенос строки
"Это строка, " \
"а это ее продолжение"
>'Это строка, а это ее продолжение'

# При этом, если была открыта какая-либо скобка ( [ {,
# обратный слеш при переносе можно не ставить - Python поймет все сам
a = [1, 2, 3,
     4, 5, 6, 7, 8, 9, 10]
>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

***
# Контрольные вопросы
* [Списки](#list)
