[содержание](/readme.md)  

# Тема 10. Знакомство с отдельными модулями<br/>Лекция 2 Регулярные выражения

[стянуто с хабра](https://habr.com/ru/post/349860/)

Регулярное выражение — это строка, задающая шаблон поиска подстрок 
в тексте. Одному шаблону может соответствовать много разных строчек. 
Термин «Регулярные выражения» является переводом английского словосочетания «Regular expressions». 
Перевод не очень точно отражает смысл, правильнее было бы «шаблонные выражения». 
Регулярное выражение, или коротко «регулярка», состоит из обычных символов и 
специальных командных последовательностей. 
Например, \\d задаёт любую цифру, а \\d+ — задает любую последовательность из одной или более цифр. 
Работа с регулярками реализована во всех современных языках программирования. 
Однако существует несколько «диалектов», поэтому функционал регулярных выражений может 
различаться от языка к языку. В некоторых языках программирования регулярками пользоваться 
очень удобно (например, в питоне), в некоторых — не слишком (например, в C++).

## Примеры регулярных выражений

Регулярка    | Её смысл
:-----------:|----------
simple text	 | В точности текст «simple text»
``\d{5}``    | Последовательности из 5 цифр<br/>``\d`` - означает любую цифру<br/>``{5}`` - ровно 5 раз
``\d\d/\d\d/\d{4}``	| Даты в формате ДД/ММ/ГГГГ<br/>(и прочие куски, на них похожие, например: 98/76/5432)
``\b\w{3}\b`` | Слова в точности из трёх букв<br/>``\b`` означает границу слова (с одной стороны буква, а с другой — нет)<br/>``\w`` - любая буква,<br/>``{3}`` - ровно три раза
``[-+]?\d+`` |	Целое число, например, 7, +17, -42, 0013 (возможны ведущие нули)<br/>``[-+]?`` - либо -, либо +, либо пусто<br/>``\d+`` - последовательность из 1 или более цифр
``[-+]?(?:\d+(?:\.\d*)?``\|``\.\d+)(?:[eE][-+]?\d+)? `` |	Действительное число, возможно в экспоненциальной записи<br/>Например, 0.2, +5.45, -.4, 6e23, -3.17E-14.

## Сила и ответственность

Регулярные выражения, или коротко, регулярки — это очень мощный инструмент. 
Но использовать их следует с умом и осторожностью, и только там, где они действительно приносят пользу, 
а не вред. Во-первых, плохо написанные регулярные выражения работают медленно. 
Во-вторых, их зачастую очень сложно читать, особенно если регулярка написана 
не лично тобой пять минут назад. В-третьих, очень часто даже небольшое изменение задачи 
(того, что требуется найти) приводит к значительному изменению выражения. 
Поэтому про регулярки часто говорят, что это write only code (код, который только пишут с нуля, 
но не читают и не правят). А также шутят: Некоторые люди, когда сталкиваются с проблемой, 
думают «Я знаю, я решу её с помощью регулярных выражений.» Теперь у них две проблемы. 
Вот пример write-only регулярки (для проверки валидности e-mail адреса (не надо так делать!!!)):

```
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|
2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
```

А вот [здесь](http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html) более точная регулярка для проверки корректности email адреса стандарту RFC822. Если вдруг будете проверять email, то не делайте так! Если адрес вводит пользователь, то пусть вводит почти что угодно, лишь бы там была собака (и точка). Надёжнее всего отправить туда письмо и убедиться, что пользователь может его получить.

## Документация и ссылки
* Оригинальная документация: https://docs.python.org/3/library/re.html;
* Очень подробный и обстоятельный материал: https://www.regular-expressions.info/;
* Разные сложные трюки и тонкости с примерами: http://www.rexegg.com/;
* Он-лайн отладка регулярок https://regex101.com (не забудьте поставить галочку Python в разделе FLAVOR слева);
* Он-лайн визуализация регулярок https://www.debuggex.com/ (не забудьте выбрать Python);

## Основы синтаксиса

Любая строка (в которой нет символов ``.^$*+?{}[]\|()``) сама по себе является регулярным выражением. Так, выражению Хаха будет соответствовать строка “Хаха” и только она. Регулярные выражения являются регистрозависимыми, поэтому строка “хаха” (с маленькой буквы) уже не будет соответствовать выражению выше. Подобно строкам в языке Python, регулярные выражения имеют спецсимволы ``.^$*+?{}[]\|()``, которые в регулярках являются управляющими конструкциями. Для написания их просто как символов требуется их экранировать, для чего нужно поставить перед ними знак ``\``. Так же, как и в питоне, в регулярных выражения выражение ``\n`` соответствует концу строки, а ``\t`` — табуляции. 

### Шаблоны, соответствующие одному символу

Во всех примерах ниже соответствия регулярному выражению выделяются курсивом.
Шаблон | Описание | Пример | Применяем к тексту
:-----:|----------|--------|-------------------
.	   | Один любой символ, кроме новой строки ``\n.`` | м.л.ко | *молоко*, *малако*, И*м0л0ко*Ихлеб
``\d`` | Любая цифра | ``СУ\d\d`` | *СУ35*, *СУ11*1, АЛ*СУ14*
``\D`` | Любой символ, кроме цифры | ``926\D123`` | *926)123*, 1*926-123*4
``\s`` | Любой пробельный символ (пробел, табуляция, конец строки и т.п.) | ``бор\sода`` | *бор ода*, *бор<br/>ода*, борода
``\S`` | Любой непробельный символ | ``\S123`` | *X123*, *я123*, *!123*456, 1 + 123456
``\w`` | Любая буква (то, что может быть частью слова), а также цифры и ``_`` | ``\w\w\w`` | *Год*, *f_3*, *qwe*rt
``\W`` | Любая не-буква, не-цифра и не подчёркивание | ``сом\W`` | *сом!*, *сом?*
``[..]`` | Один из символов в скобках,<br/>а также любой символ из диапазона a-b | ``[0-9][0-9A-Fa-f]`` | *12*, *1F*, *4B*
``[^..]`` | Любой символ, кроме перечисленных | ``<[^>]>`` | *<1>*, *<a>*, <>>
``\d≈[0-9], \D≈[^0-9], \w≈[0-9a-zA-Zа-яА-ЯёЁ], \s≈[ \f\n\r\t\v]`` | Буква “ё” не включается в общий диапазон букв!<br/>
Вообще говоря, в ``\d`` включается всё, что в юникоде помечено как «цифра», а в ``\w`` — как буква. Ещё много всего! | |
``[abc-], [-1]`` | если нужен минус, его нужно указать последним или первым	| |
``[*[(+\\\]\t]`` | внутри скобок нужно экранировать только ``]`` и ``\`` | |		
``\b`` | Начало или конец слова (слева пусто или не-буква, справа буква и наоборот).<br/>
В отличие от предыдущих соответствует позиции, а не символу | ``\bвал`` | *вал*, перевал, Перевалка
``\B`` | Не граница слова: либо и слева, и справа буквы,
либо и слева, и справа НЕ буквы | ``\Bвал`` | пере*вал*, вал, Пере*вал*ка
 | | ``\Bвал\B`` | перевал, вал, Пере*вал*ка

### Квантификаторы (указание количества повторений)

Шаблон | Описание | Пример | Применяем к тексту
:-----:|----------|--------|-------------------
``{n}``| Ровно n повторений | ``\d{4}`` | 1, 12, 123, *1234*, 12345
``{m,n}`` | От m до n повторений включительно | ``\d{2,4}`` | 1, *12*, *123*, *1234*, 12345
``{m,}`` | Не менее m повторений | ``\d{3,}`` | 1, 12, *123*, *1234*, *12345*
``{,n}`` | Не более n повторений | ``\d{,2}`` | *1*, *12*, *12*3
``?`` | Ноль или одно вхождение, синоним ``{0,1}`` | ``валы?`` | *вал*, *валы*, *вал*ов
``*`` | Ноль или более, синоним {0,} | ``СУ\d*`` | *СУ*, *СУ1*, *СУ12*, ...
``+`` | Одно или более, синоним {1,} | ``a\)+`` | *a)*, *a))*, *a)))*, b*a)*])
``*? +? ?? {m,n}? {,n}? {m,}?``|По умолчанию квантификаторы жадные — 
захватывают максимально возможное число символов. Добавление ``?`` делает их ленивыми, 
они захватывают минимально возможное число символов | ``\(.*\)`` | *(a + b) * (c + d) * (e + f)*
 | | ``\(.*?\)`` | *(a + b)* * (c + d) * (e + f)

### Жадность в регулярках и границы найденного шаблона

Как указано выше, по умолчанию квантификаторы жадные. Этот подход решает очень важную проблему — проблему границы шаблона. Скажем, шаблон ``\d+`` захватывает максимально возможное количество цифр. Поэтому можно быть уверенным, что перед найденным шаблоном идёт не цифра, и после идёт не цифра. Однако если в шаблоне есть не жадные части (например, явный текст), то подстрока может быть найдена неудачно. Например, если мы хотим найти «слова», начинающиеся на СУ, после которой идут цифры, при помощи регулярки ``СУ\d*``, то мы найдём и неправильные шаблоны: 

ПА*СУ13* *СУ12*, ЧТОБЫ *СУ6*ЕНИЕ УДАЛОСЬ.

В тех случаях, когда это важно, условие на границу шаблона нужно обязательно добавлять в регулярку. О том, как это можно делать, будет дальше. 

### Пересечение подстрок

В обычной ситуации регулярки позволяют найти только непересекающиеся шаблоны. Вместе с проблемой границы слова это делает их использование в некоторых случаях более сложным. Например, если мы решим искать e-mail адреса при помощи неправильной регулярки ``\w+@\w+`` (или даже лучше, ``[\w'._+-]+@[\w'._+-]+``), то в неудачном случае найдём вот что: 

*foo@boo*@*goo@moo*@*roo@zoo*

То есть это с одной стороны и не e-mail, а с другой стороны это не все подстроки вида текст-собака-текст, так как boo@goo и moo@roo пропущены. 

## Эксперименты в песочнице

Если вы впервые сталкиваетесь с регулярными выражениями, то лучше всего сначала попробовать песочницу. Посмотрите, как работают простые шаблоны и квантификаторы. Решите следующие задачи для этого текста (возможно, к части придётся вернуться после следующей теории):
* Найдите все натуральные числа (возможно, окружённые буквами);
* Найдите все «слова», написанные капсом (то есть строго заглавными), возможно внутри настоящих слов (аааБББввв);
* Найдите слова, в которых есть русская буква, а когда-нибудь за ней цифра;
* Найдите все слова, начинающиеся с русской или латинской большой буквы (``\b`` — граница слова);
* Найдите слова, которые начинаются на гласную (``\b`` — граница слова);
* Найдите все натуральные числа, не находящиеся внутри или на границе слова;
* Найдите строчки, в которых есть символ * (. — это точно не конец строки!);
* Найдите строчки, в которых есть открывающая и когда-нибудь потом закрывающая скобки;
* Выделите одним махом весь кусок оглавления (в конце примера, вместе с тегами);
* Выделите одним махом только текстовую часть оглавления, без тегов;
* Найдите пустые строчки;

## Регулярки в питоне

Функции для работы с регулярками живут в модуле **re**. Основные функции:

Функция	| Её смысл
--------|----------
re.search(pattern, string) | Найти в строке string первую строчку, подходящую под шаблон pattern;
re.fullmatch(pattern, string) | Проверить, подходит ли строка string под шаблон pattern;
re.split(pattern, string, maxsplit=0) | Аналог str.split(), только разделение происходит по подстрокам, подходящим под шаблон pattern;
re.findall(pattern, string)	| Найти в строке string все непересекающиеся шаблоны pattern;
re.finditer(pattern, string) | Итератор всем непересекающимся шаблонам pattern в строке string (выдаются match-объекты);
re.sub(pattern, repl, string, count=0) | Заменить в строке string все непересекающиеся шаблоны pattern на repl;

Пример использования всех основных функций

```py
import re 

match = re.search(r'\d\d\D\d\d', r'Телефон 123-12-12') 
print(match[0] if match else 'Not found') 
# -> 23-12 

match = re.search(r'\d\d\D\d\d', r'Телефон 1231212') 
print(match[0] if match else 'Not found') 
# -> Not found 

match = re.fullmatch(r'\d\d\D\d\d', r'12-12') 
print('YES' if match else 'NO') 
# -> YES 

match = re.fullmatch(r'\d\d\D\d\d', r'Т. 12-12') 
print('YES' if match else 'NO') 
# -> NO 

print(re.split(r'\W+', 'Где, скажите мне, мои очки??!')) 
# -> ['Где', 'скажите', 'мне', 'мои', 'очки', ''] 

print(re.findall(r'\d\d\.\d\d\.\d{4}', 
                 r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017')) 
# -> ['19.01.2018', '01.09.2017'] 

for m in re.finditer(r'\d\d\.\d\d\.\d{4}', r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017'): 
    print('Дата', m[0], 'начинается с позиции', m.start()) 
# -> Дата 19.01.2018 начинается с позиции 20 
# -> Дата 01.09.2017 начинается с позиции 45 

print(re.sub(r'\d\d\.\d\d\.\d{4}', 
             r'DD.MM.YYYY', 
             r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017')) 
# -> Эта строка написана DD.MM.YYYY, а могла бы и DD.MM.YYYY 
```

## Тонкости экранирования в питоне (``'\\\\\\\\foo'``)

Так как символ ``\`` в питоновских строках также необходимо экранировать, то в результате в шаблонах могут возникать конструкции вида ``'\\\\par'``. Первый слеш означает, что следующий за ним символ нужно оставить «как есть». Третий также. В результате с точки зрения питона ``'\\\\'`` означает просто два слеша ``\\``. Теперь с точки зрения движка регулярных выражений, первый слеш экранирует второй. Тем самым как шаблон для регулярки ``'\\\\par'`` означает просто текст ``\par``. Для того, чтобы не было таких нагромождений слешей, перед открывающей кавычкой нужно поставить символ **r**, что скажет питону «не рассматривай ``\`` как экранирующий символ (кроме случаев экранирования открывающей кавычки)». Соответственно можно будет писать ``r'\\par'``. 

## Использование дополнительных флагов в питоне

Каждой из функций, перечисленных выше, можно дать дополнительный параметр flags, что несколько изменит режим работы регулярок. В качестве значения нужно передать сумму выбранных констант, вот они:
Константа | Её смысл
----------|----------
re.ASCII | По умолчанию ``\w, \W, \b, \B, \d, \D, \s, \S`` соответствуют все юникодные символы с соответствующим качеством.<br/>Например, ``\d`` соответствуют не только арабские цифры, но и вот такие: ``٠١٢٣٤٥٦٧٨٩``.<br/>re.ASCII ускоряет работу, если все соответствия лежат внутри ASCII.
re.IGNORECASE | Не различать заглавные и маленькие буквы. Работает медленнее, но иногда удобно
re.MULTILINE | Специальные символы ``^`` и ``$`` соответствуют началу и концу каждой строки
re.DOTALL | По умолчанию символ ``\n`` конца строки не подходит под точку. С этим флагом точка — вообще любой символ

```py
import re 

print(re.findall(r'\d+', '12 + ٦٧')) 
# -> ['12', '٦٧'] 

print(re.findall(r'\w+', 'Hello, мир!')) 
# -> ['Hello', 'мир'] 

print(re.findall(r'\d+', '12 + ٦٧', flags=re.ASCII)) 
# -> ['12'] 

print(re.findall(r'\w+', 'Hello, мир!', flags=re.ASCII)) 
# -> ['Hello'] 

print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя')) 
# -> ['ааааа', 'яяяя'] 

print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя', flags=re.IGNORECASE)) 
# -> ['ОООО', 'ааааа', 'ЫЫЫЫ', 'яяяя'] 

text = r""" 
Торт 
с вишней1 
вишней2 
""" 
print(re.findall(r'Торт.с', text)) 
# -> [] 

print(re.findall(r'Торт.с', text, flags=re.DOTALL)) 
# -> ['Торт\nс'] 

print(re.findall(r'виш\w+', text, flags=re.MULTILINE)) 
# -> ['вишней1', 'вишней2'] 

print(re.findall(r'^виш\w+', text, flags=re.MULTILINE)) 
# -> ['вишней2'] 
```

[содержание](/readme.md)  
