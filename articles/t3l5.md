# Тема 3. Программирование на языке Python</br>Лекция 5


[Часть 2](#part2)

<a name="codepages"></a>

## Кодировки символов: ANSI, UTF-8, UNICODE.
Прежде чем разбираться с кодировкой символов разберемся как компьютер вообще хранит информацию.

У нас 10 пальцев, и система — десятичная. То есть, любое, сколь угодно большое число мы можем представить с помощью цифр 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. В зависимости от того, где в числе стоит цифра, она может означать разное: если эта цифра последняя, то она расположена в разряде единиц, предпоследняя — разряд десятков, еще левее — разряд сотен и так далее. По сути, любое число можно расписать в виде суммы цифр, каждая из которых умножена на десять в определенной степени. В случае единиц, эта степень — нулевая.

Например,

1573 = 3\*10<sup>0</sup> + 7\*10<sup>1</sup> + 5\*10<sup>2</sup> + 1\*10<sup>3</sup>

Число, на степень которого умножаются цифры называется базой системы счисления. Для десятичной системы базой, логично, является десятка.

У компьютера пальцев нет, но есть два состояния: условно «ток идет» и «ток не идет», нулик и единичка. Соответственно все числа (да и вообще информация) в памяти компьютера состоят только из двух цифр — 0 и 1. Их расположение, как и в случае десятичной системы счисления, указывает на разряд. Только теперь число можно разложить на сумму цифр, помноженных не на степени десятки, а степени двойки.

0 в двоичной системе = 0</br>
1 в двоичной системе = 1</br> 
2 в двоичной системе = 10</br>
7<sub>10</sub>=111<sub>2</sub></br>

Научитесь переводить из двоичной системы в десятичую. Вы, наверное, уже поняли, как это делается — просто берем цифру числа начиная с самой правой и умножаем её на базу системы счисления в степени, соответствующей её разряду, так с каждым разрядом. Затем складываем все получившиеся таким образом числа.

Пример:

Давайте найдем десятичный аналог двоичного числа 101101<sub>2</sub>

Самая правая единичка = 1\*2<sup>0</sup></br>
Следующий нулик = 0\*2<sup>1</sup></br>
Третья справа единичка = 1\*2<sup>2</sup></br>
Четвертая = 1\*2<sup>3</sup></br>
… и так далее</br>

101101<sub>2</sub> = 1\*2<sup>0</sup> + 0\*2<sup>1</sup> + 1\*2<sup>2</sup> + 1\*2<sup>3</sup> + 0\*2<sup>4</sup> + 1\*2<sup>5</sup> = 1 + 0 + 4 + 8 + 0 + 32 = 45<sub>10</sub>

### Перевод из десятичной системы в двоичную
Тут тоже всё просто, если понимать суть.

Пример:

У нас есть десятичное число 57<sub>10</sub>. Чтобы перевести его в двоичную систему, нужно определить, какая максимальная степень двойки не превосходит это число.

2<sup>6</sup> = 64.  
Это явно многовато.  
А вот 2<sup>5</sup> = 32.  

Мы определили старший разряд. 32<sub>10</sub> = 100000<sub>2</sub>.  
Теперь ищем следующий разряд. 57-32 = 25.  
Теперь для 25 ищем степень двойки, которая не превосходит 25.  
2<sup>4</sup> = 16.  
Значит, следующий разряд у нас тоже равен "1".  
32+16 = 48<sub>10</sub> = 110000<sub>2</sub>.  
57 – 48 = 9.  
2<sup>3</sup> = 8, это больше, чем 9. Значит следующий разряд тоже будет единичкой.

32 + 16 + 8 = 56<sub>10</sub> = 111000<sub>2</sub>.  
57 - 56 = 1, то есть осталась только одна степень 2<sup>0</sup>.  
Таким образом, 57<sub>10</sub> = 111001<sub>2</sub>.

### ASCII
Мы выяснили, что компьютер понимает только нулики и единички, а его память можно представить в виде очень длинной строки из лампочек с выключателями. Как представить цифры в компьютере мы уже поняли. А что делать с остальной информацией? Буквами, картинками?

Скажем, в английском алфавите 26 букв. Теоретически мы можем представить буквы цифрами от 0 до 25, только в двоичной системе. Возникает другой вопрос: а как понять, перед нами строчная буква или прописная? А знаки препинания? Что делать со знаками-«невидимками», вроде пробела? Словом, нужна система кодирования.

В 1960-х годах существовало множество разных схем, кодирующих символы. Отсутствие единообразия довольно быстро переросло в серьёзную проблему, и уже в 1963 году Американский институт стандартизации ANSI разработал и ввел в обиход схему кодировки ASCII (American Standard Code for Information Interchange). 

Каждый символ ASCII состоит из семи разрядов или семи бит, каждый из которых может принимать значение 0 или 1. В 7 бит можно поместить числа от 0 до 127 в двоичной системе, то есть у нас есть 128 чисел для кодирования символов. Казалось бы, достаточно для кодировки письменной английской речи? 

Давайте прикинем: 

a-z — 26 вариантов  
A-Z — еще 26  
0-9 — 10  
,;:~& и прочие знаки пунктуации — 32  
Ещё нам нужен пробел.  
Итого — 95 символов.  

Оставшиеся 33 (128 - 95) вакантных варианта используют для так называемых управляющих символов, вроде перевода строки или возврата каретки.

Важно различать символы "0"-"9" и числовые значения 0-9.
Символы "0"-"9" представлены значениями ASCII 48-57 (0x30-0x39).

Интересно отметить, что крайние правые четыре бита этих значений ASCII представляют собой двоичные представления числовых значений 0-9. Это несколько упрощает способ преобразования между значениями ASCII и их фактическими числовыми значениями (в шестнадцатиричном виде это особенно заметно).

С появлением восьмибитной кодировки, в ASCII смогли закодировать и другие алфавиты. Расширенных кодировок ASCII много - существуют версии для многих национальных алфавитов. При этом первая половина кодировки (значения от нуля до 127) везде одинаковая.

Русский алфавит (кириллица) закодирован в кодировке с названием windows-1251 (Это актуальная кодировка для Windows, но и до неё существовало несколько кодировок. Наиболее распространены были CP866 и КОИ-8r, вы вполне можете с ними столкнуться при работе со старым "железом" или сайтами).


### Кодировка Юникод (Unicode)
Один байт может иметь только 256 значений. Это значит, что в кодировке ASCII можно закодировать 256 символов: цифр, букв, пиктограмм, знаков пунктуации и других различных символов. В то же время существуют письменности, в которых гораздо больше символов, например, китайские или японские иероглифы.

Для решения этой (и некоторых других) проблемы в начале девяностых была создана кодировка Юникод(Unicode). Первоначально все символы юникода занимали два байта. Соответственно, в unicode можно было закодировать 2<sup>16</sup> = 65536 значений. Затем кодовое пространство было расширено до более чем миллиона символов. В результате этого появилось несколько представлений юникода.

Наиболее популярными представлениями юникода являются два: **UTF-8** - используется в интернете и **UTF-16** - используется в Windows (начиная с Windows XP).

Существует две версии UTF-16: UTF-16LE (little-endian) - кодировка с обратным порядком байтов и UTF-16BE (big-endian) - кодировка с прямым порядком байтов. В Windows используется UTF16-LE.

Код символов в юникоде обозначается так: U+hhhh (четыре шестнадцатеричных цифры,h - от hexadecimal - шестнадцатеричный). Например, U+221A - символ квадратного корня - √.

Часть символов в UTF-16 кодируются двумя байтами (первые 63 тысячи). Остальные символы кодируются суррогатными парами. 

В **UTF-8** первые 128 символов кодируются одним байтом. Остальные символы могут кодироваться несколькими байтами (от двух до четырёх). Именно поэтому длина строки в юникоде не равна длине буфера, который эта строка занимает. Это нужно учитывать при обмене данными.

И ещё один момент (самый важный): в юникод закодированы все символы всех современных и многих мёртвых письменностей плюс знаки из различных областей науки и культуры (математические и экономически символы, нотные знаки и многое другое). Именно по этой причине и нужно использовать юникод.

### Кодирование текста в Microsoft Windows (начиная с Windows XP)
В современных версиях Windows существует два способа представления текста: UTF-16 и кодовые страницы (в основном это восьмибитные кодировки). Основной способ - юникод. Кодовые страницы нужны для совместимости со старыми приложениями (в Windows 95, Windows 98 - в основном использовалась ASCII). Кроме того, юникод не понимает одна очень важная программа - консоль.

Пусть вас не смущает новый термин - кодовая страница (code page). В windows так называются все кодировки (character sets или encodings). Т.е. понятие кодировка равнозначно кодовой странице.

Сразу сделаю замечание, которое лучше запомнить. В Windows есть чёткое разделение: вот юникод (UTF-16LE), а вот все остальные кодировки. И юникод, и остальные кодировки в Windows называются кодовыми страницами, но этот термин (кодовые страницы) я буду применять ко всем кодировкам за исключением юникода.

Напомню, что в Питоне используется кодировка UTF-8.

>Ниже мы подробно рассмотрим работу со сложными типами.
В тексте могут быть описаны не все методы, т.к. язык постоянно развивается и в следующих версиях могут добавиться новые методы.
>
>В редакторе, поддерживающем технологию IntelliSenese, Вы в любое время можете посмотреть какие методы реализует объект. Достаточно поставить точку после названия объекта и нажать комбинацию клавиш \<ctrl>+<пробел>. А, чтобы узнать параметры метода, достаточно навести на него курсор мышки.

<a name="list"></a>

## Работа со списками.
Список - **изменяемая** коллекция объектов произвольных типов.

Создать список можно несколькими способами. Например, можно обработать любой итерируемый объект (например, строку) встроенной функцией **list**:
```python
>>>my_list = list("список")
['с', 'п', 'и', 'с', 'о', 'к']
```

Список можно создать и при помощи литерала **[]**:
```python
list_1 = []  # Пустой список
list_2 = ['s', 'p', ['isok'], 2]
```

Еще один способ создать список - это **генераторы** списков. Генератор списков - способ построить новый список, применяя выражение к каждому элементу последовательности. Генераторы списков очень похожи на цикл for:
```python
list_3 = [c * 3 for c in 'list']
```

Генератор расшифровывается просто: выполнить операцию (выражение до ключевого слова for) для каждого элемента итерируемого объекта и поместить результат в список. Причем сам элемент можно и не использовать, помните как мы получали с клавиатуры несколько значений:
```python
list_4 = [input('введите число: ') for _ in range(5)]
```

Возможна и более сложная конструкция генератора списков:
```python
# обрабатывать элемент с условием (не равен 'i')
c = [c * 3 for c in 'list' if c != 'i']
['lll', 'sss', 'ttt']

# вложенный цикл
c = [c + d for c in 'list' if c != 'i' for d in 'spam' if d != 'a']
['ls', 'lp', 'lm', 'ss', 'sp', 'sm', 'ts', 'tp', 'tm']
```

## Функции и методы списков
Рассмотрим на примере списка a = [1,2,3]
* list.append( element ) - добавляет элемент в конец списка  
    ``a.append(4) #a=[1,2,3,4]``
* list.extend( other_list )	- расширяет список list, добавляя в конец все элементы списка other_list  
    ``a.extent([5,5,6]) #a=[1,2,3,4,5,5,6]``
* list.insert(i, x)	- вставляет на i-ый элемент значение x  
    ``a.insert(0, 0) #a=[0,1,2,3,4,5,5,6]``
* list.remove(x) - Удаляет первый элемент в списке, имеющий значение x.</br> Выдаст исключение ValueError, если такого элемента не существует  
    ``a.remove(6) #a=[0,1,2,3,4,5,5]``
* list.pop([i]) - Удаляет i-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент (квадратные скобки тут обозначают не массив, а опциональность параметра)  
    ``b = a.pop(5); #b=5, a=[0,1,2,3,4,5]``
* list.index(x, [start [, end]]) - Возвращает положение первого элемента со значением x (при этом поиск может вестись от start до end)  
    ``i = a.index(2) #i=2``
* list.count(x) -	Возвращает количество элементов со значением x
* list.sort(key=None, reverse=False) -> None  
    ``-> None`` означает, что функция ничего не возвращает, она меняет сам список (тип результата появился в Python 3)</br>
    По-умолчанию (если не указан ни один параметр) сортирует по алфавиту, а также от меньшего значения к большему, например:
```python
a = ['cc','a','bbb']
a.sort()
['a','bbb','cc']
```

Можно поменять порядок сортировки, указав reverse=True:
```python
a = ['cc','a','bbb']
a.sort(reverse=True)
['cc','bbb','a']
```

С помощью параметра *key* можно поменять принцип сортировки, например, не по алфавиту, а по длине строки:
```python
#Создаем "внешнюю" функцию, которая будет возвращать длину строки
def sortByLength(inputStr):
    return len(inputStr)

a = ['cc','a','bbb']
a.sort(key=sortByLength)
['a','cc','bbb']
```
т.е. при сортировке сравниваются не элементы, а результаты функции sortByLength в которую каждый элемент передается при сортировке (возможно вместо написания новой функции можно было сразу указать ``key=len``, но принцип понятен).

В Python 2 вместо параметра *key* был параметр *cmp*, которому тоже присваивалась функция, но в отличии от нового варианта, где решение *больше, меньше* принимет метод sort, там решение принимала функция.

Функция, принимает аргументами два стоящих рядом элемента, и должна вернуть отрицательное число (если первый меньше второго), нуль (если равны) и положительное (если первый больше второго).
```python
#Создаем "внешнюю" функцию, которая будет "говорить" что все элементы одинаковые
def my_sort(inputStr):
    return 0

a = ['cc','a','bbb']
a.sort(cmp=my_sort)
['cc','a','bbb']
```

Хоть в Python 3 она больше и не используется, но знать о ней нужно, чтобы понимать старый код.

В Python 2.6 и в более ранних версиях способ упорядочения основан на именах типов, вовлеченных в операцию сравнения, например любые целые числа всегда меньше любых строк. При выполнении операции сравнения никогда не выполняется преобразование типов объектов, за исключением сравнивания объектов числовых типов. 

В Python 3.0 такой порядок был изменен: попытки сравнивания объектов различных типов возбуждают исключение. Так как метод сортировки использует операцию сравнения, это означает, что инструкция [1, 2, 'spam'].sort() будет успешно выполнена в Python 2.X, но возбудит исключение в версии Python 3.0 и выше. 

* list.reverse() - Разворачивает список (в принципе то же самое, что ``sort(reverse=True)``)
* list.copy() - возвращает копию списка, т.е. создает новый список и заполняет его теми же элементами (надо помнить, что если мы просто присвоим один список другому ``a=b``, то копирования данных при этом не происходит, а просто копируется ссылка на существующий объект списка)
* list.clear() - Очищает список

<a name="tuple"></a>

## Кортеж (tuple)
Кортеж (tuple) – это неизменяемая структура данных, которая по своему подобию очень похожа на список.

### Зачем нужны кортежи в Python?
Существует несколько причин, по которым стоит использовать кортежи вместо списков. Одна из них – это обезопасить данные от случайного изменения. Если мы получили откуда-то массив данных, и у нас есть желание поработать с ним, но при этом непосредственно менять данные мы не собираемся, тогда, это как раз тот случай, когда кортежи придутся как нельзя кстати. Используя их в данной задаче, мы дополнительно получаем сразу несколько бонусов – во-первых, это экономия места. Дело в том, что кортежи в памяти занимают меньший объем по сравнению со списками.

Во-вторых – прирост производительности, который связан с тем, что кортежи работают быстрее, чем списки (т.е. на операции перебора элементов и т.п. будет тратиться меньше времени). Важно также отметить, что кортежи можно использовать в качестве ключа у словаря.

### Создание, удаление кортежей и работа с его элементами

**Создание кортежей**</br>
Для создания пустого кортежа можно воспользоваться одной из следующих команд.
```python
a = ()
b = tuple()
```

Кортеж с заданным содержанием создается также как список, только вместо квадратных скобок используются круглые.
```python
a = (1, 2, 3, 4, 5)
```

При желании можно воспользоваться функцией tuple().
```python
a = tuple((1, 2, 3, 4))
```

**Доступ к элементам кортежа**</br>
Доступ к элементам кортежа осуществляется также как к элементам списка – через указание индекса. Но, как уже было сказано – изменять элементы кортежа нельзя!
```python
a = (1, 2, 3, 4, 5)
print(a[0])
print(a[1:3])
```

**Удаление кортежей**</br>
Удалить отдельные элементы из кортежа невозможно, но можно удалить кортеж целиком.
```python
del a
```

**Преобразование кортежа в список и обратно**</br>
На базе кортежа можно создать список, верно и обратное утверждение. Для превращения списка в кортеж достаточно передать его в качестве аргумента функции tuple().
```python
new_tuple = tuple([1,2,3])
```

Для получения списка из кортежа используется функция list:
```python
new_list = list( (1,2,3) )
```

Фактически, кортежи вообще поддерживают те же операции с последовательностями, как и строки: объединение (a+b), клонирование (a*3)

**Список методов**</br>
Кортежи в Python имеют всего два метода: index() и count(). Поведение аналогично таким же методам у списка.
```python
(1, 32, 34, 45).index(32) # 1
(2, 32, 36, 43, 32, 143, 32).count(32) # 3
```

**Меняем данные**
После создания кортежа в Python нельзя менять его структуру. Однако вы сможете управлять данными внутри него. Рассмотрим на примере:
```python
a = [] # пустой список
b = {} # пустой словарь
c = (a, b) # наш кортеж с данными
print(c) # получим на выводе ([], {})

a.append('ROOT') # добавили новое значение в список
b['name'] = 'Максим' # новое значение в словарь
print(c) # получим (['ROOT'], {'name': 'Максим'})
```

Все дело в том ,что кортеж хранит два объекта и структура кортежа не изменилась, изменилось содержимое объектов.

<a name="dict"></a>

## Работа со словарями
Итак, словарь — это **изменяемый** и **неупорядоченный** объект.

Давайте вспомним списки в Python: [1, 2, 3, 4, 5] при отображении данного списка он в таком же порядке и будет выведен, так как список является упорядоченным. Со словарями все немного по-другому. В зависимости от версии Python при выводе словаря он может выводиться совершенно в другом порядке. Но есть одна особенность: вызов определенных данных со словаря возможен по ключам. В коде Python словари обозначаются фигурными скобками {}. Сама структура словаря выглядит так: {key: data, key2: data}.

>Возможно Python не первый язык программирования, который вы изучаете. Если это так, то вы ранее должны были сталкиваться с массивами. Так вот, словарь по сути тот же ассоциативный массив к примеру в PHP.

Рассмотрим все на примере, создадим словарь: data = {'red': 'Красный', 'green': 'Зеленый'}. Переменная data содержит некие данные, где ключ к данным на английском языке, а содержание на русском. То есть некий переводчик.

Пробуем получить наши данные: ``print(data['red'])``. Получение данных в отличии от списков только в том, что здесь все по ключу.

Так же есть еще и другой способ создания словарей c помощью функции dict(key='data', key2='data'). Это уже дело вкуса. Создавайте так, как вам удобно.

Давайте на примере этого словаря рассмотрим операции, которые с ним можно проводить.

Для того чтобы подсчитать элементы в словаре используем уже знакомую нам  *функцию* **len()**. При ``print(len(data))`` мы увидим количество элементов в словаре (2).

**keys()**
Для того чтобы вывести список ключей необходимо использовать *метод* keys(). Используем код ``print(list(data.keys()))``, в итоге мы получаем список ключей в нашем словаре: ['red','green'].

**values()**
Для того чтобы вывести список значений, а не ключей следует использовать *метод* values(). В итоге мы получаем такой код ``print(list(data.values()))``, это приведет к тому, что в создаваемый нами список будет вставлен список значений из словаря: ['красный','зеленый'].

**items()**
А вот для того чтобы получить список значений и ключей стоит использовать *метод* items(). Код ``list(data.items())`` создаст новый список с уже вложенными элементами: [('red', 'красный'), ('green', 'зеленый')].

**del**
Если нужно удалить элемент словаря стоит использовать *функцию* del: ``del data('red')``, останется список с одним элементом {'green':'зеленый'} (тут похоже пример в нотации Python 2, надо попробовать вариант ``del( data('red') )``).

**Добавление данных в словарь**
Для того чтобы добавить данные в словарь необходимо только указать новый ключ, а также определить его значение. К примеру, ``data['blue'] = 'синий'``, получим список {'green':'зеленый', 'blue':'синий'}.

**Метод fromkeys()**</br>
fromkeys(seq[, value])  -> dict 

Возвращает новый словарь, сформированный из указанной последовательности, с указанным значением элементов (не обязательный параметр).

* seq - Любая последовательность, например список list.
* value - Необязательный аргумент. Значение для каждого элемента списка. Если не задан, в качестве значений используется None.
```python
my_new_dict = dict.fromkeys(['one', 'two', 3])  
# {'one': None, 'two': None, 3: None}

my_new_dict = dict.fromkeys(['one', 'two', 3], 10)  
# {'one': 10, 'two': 10, 3: 10}
```

**Метод get()**</br>
dict.get(key[, default]) -> Значение по ключу, либо default.

Возвращает значение из словаря по указанному ключу.

* key - Ключ, значение по которому требуется получить.
* default - Значение, которое следует вернуть, если в словаре не окажется указанного ключа. По умолчанию — None.

В случае, если ключ не найден в словаре возвращает значение аргумента default. Таким образом, исключение KeyError при использование данного метода не возбуждается никогда (в этом и отличие от простого доступа по ключу ``dict[key]``).

**Метод popitem()**</br>
dict.popitem()  -> tuple,  Кортеж вида (ключ, значение)

Возвращает произвольную пару (ключ, значение) и удалят её из словаря.

Может применяться при необходимости обработать все значения словаря. Аналогом (если данные удалять не нужно) может быть вызов метода keys() и последующий перебор значений в цикле.
```python
a = dict(...)
keys = a.keys()
for i in keys:
    print( a[i] )
```

**Метод setdefault()**</br>
dict.setdefault(key[, default])  -> Значение по ключу, либо default

Возвращает значение по ключу, инициализируя элемент словаря, если необходимо, указанным значением.

* key - Ключ, значение по которому следует получить, если таковое имеется в словаре, либо создать.
* default=None = Значение, которое будет использовано при добавлении нового элемента в словарь.

Позволяет получить значение из словаря по ключу. Автоматически добавляет элемент словаря, если он отсутствует (если ключ есть, то по идее ничего не должен изменять - проверить на практике). 

**Метод update()**</br>
dict.update([other]**kwargs) -> None

>D.update([E, ]**F) -> None</br>
Update D from dict/iterable E and F.</br>
If E is present and has a .keys() method, then does:</br> 
for k in E: D[k] = E[k]</br> 
If E is present and lacks a .keys() method, then does: </br>
for k, v in E: D[k] = v </br>
In either case, this is followed by: for k in F: D[k] = F[k]</br>

обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Позволяет обновить данные словаря, или дополнить их.

* other - Необязательный аргумент. Другой словарь, либо итерируемый объект с парами ключ, значение (кортеж, либо другой итерируемый объект с двумя элементами).
```python
d = {'x': 2}
""" список выражений, название переменной одновременно станет названием ключа.
Я уже неоднократно отмечал, что всё в Питоне является объектами, а у объекта есть свойства 'имя' и 'значение' """
d.update(y = 3, z = 0) 

# аналогично предыдущему примеру
c=5; d=6
d.update(c, d) 

# список из пар объектов
d.update([('a',1),('b',4)])
```

* **kwargs - Необязательный аргумент. Именованные аргументы значениями которых требуется обновить словарь. Если используется вместе с other, значения из именованных аргументов имеют приоритет.

Есть методы аналогичные методам списков:

**Метод pop()**</br>
dict.pop(key[, default]) -> Значение по ключу, default либо исключение.

Возвращает значение по указанному ключу и убирает элемент из словаря.

* key - Ключ, значение по которому следует добыть
* default - Значение, которое следует вернуть, если указанный ключ отсутствует в словаре. Если не указано, при отсутствии ключа возбуждается исключение KeyError.

**Метод clear()**
Очищает словарь.

**Метод copy()**
Делает копию словаря (мы помним, что при простом присваивании переменных происходит только присваивание указателя на существующий объект).

Важно также понять вложенность словарей. Если в примере выше нашими ключами в словарях служили только строки, и значение ключей тоже были исключительно строчными, то на практике все будет иначе.

Словари в Python могут содержать все что угодно. Значением может быть число, строка, функция, объект или даже сам словарь внутри словаря со своими вложениями.

<a name="set"></a>

## Объявление множества. Операции над множествами.
Множества — неупорядоченные наборы уникальных объектов, поддерживающих хеширование.

Множества не упорядочены, они не хранят ни позицию элемента, ни порядок вставки. Поэтому наборы не поддерживают ни обращение к элементам по индексам, ни срезы, ни какое-либо другое поведение, присущее последовательностям.

Множества обычно используются для проверки вхождения элемента, устранения из последовательности дубликатов, и таких математических операций как: пересечение,объединение, разница и симметичная разница.

Для создания множества используется функция **set**, в параметрах любой список.
```python
a = set([1,2,3,4,5,6])
```

### Операции над множествами
Множество итерируемый объект, можно использовать в операции **for**:
```python
for item in {1, 2, 'some'}:
    print(item)
```

**Количество элементов** в последовательности можно получить, используя функцию len().
```python
    len({1, 2, 'some'})  # 3
```

**Сравнение**</br>
Два множества равны тогда и только тогда, когда каждый из элементов множества содержится во втором (когда каждое из множест является подмножеством другого).
```python
set({1,2,3}) == set({3,2,1}) # True
```

Одно множество больше другого тогда и только тогда, когда первое является правильным надмножеством последнего (является надмножеством, но не равно).
```python
set({1,2,3}) > set({2,1}) # True
```

Два любых непустых непересекающихся множества не являются равными и не являются подмножествами друг для друга, поэтому следующию сравнения вернут False: a == b,a > b, a < b. 
```python
set({1,2,3}) > set({4,1}) # False
```

**copy()**
Возвращает копию множества.
```python
set_1 = {1, 2, 3}
set_2 = set_1.copy()

set_1 == set_2  # True (содержимое одинаковое)
set_1 is set_2  # False (но объекты разные)
```

**difference(*others)**</br>

>TODO: Описать остальные методы

<a name="part2"></a>

>Из своей практики могу предположить что в таких объектах удобно хранить состояние какого-нибудь "железа", например, принтера:</br>
кончилась бумага - модуль добавил это событие (просто строка 'no paper') в множество. Одновременно двух одинаковых событий быть не может, поэтому дублирования не будет, а при появлении бумаги событие просто удаляется из множества.</br></br>
Это же самое можно просто закодировать в переменной с типом "целое" и помещать/извлекать события соответствующими битовыми операциями (|, ~&), но множество не ограничего размерами и одновременно хранит текст события.

<a name="strings"></a>

## Операции над строками
//TODO: много недорассказанного, вычитал дальше - слепить вместе
Основные операции мы уже рассмотрели, но как выяснилось на практическом занятии остался один важный вопрос - преобразование типов

### Функция ord
ord(символ) -> int

Эта функция возвращает ASCII код символа

### Функция chr
chr(число) -> символ

Эта функция, наоборот, по коду возвращает соответствующий символ

### Функция ascii
ascii(object) -> string

Возвращает "печатаемое" представление объекта
```python
ascii('тест')
'\u0442\u0435\u0441\u0442'
```

### str(object='') -> строка</br>str(object=b'', encoding='utf-8', errors='strict') -> строка
Преобразует *object* в строку используя *encoding*, при возникновении ошибки преобразования поступает в соответствии с *errors*. 

Первый вариант работает (преобразование строки с кодами из предыдущего примера в обычную строку)
```python
str('\u0442\u0435\u0441\u0442')
>тест
```

>TODO: а вот второй нихрена не понял как работет, постоянно вылетает TypeError

### Метод encode
строка.encode(<кодировка>) -> байтовая строка

Преобразование в строку байт в соответствии с выбранной кодировкой
```python
"привет".encode('windows-1251')
>b'\xef\xf0\xe8\xe2\xe5\xf2'
```

<a name="binary"></a>

# Binary Sequence Types — bytes, bytearray, memoryview
Встроенные типы для работы с двоичными данными.

>The core built-in types for manipulating binary data are bytes and bytearray. They are supported by memoryview which uses the buffer protocol to access the memory of other binary objects without needing to make a copy.

## Байтовые строки (bytes)
Байтовые строки очень похожи на обычные строки, но с некоторыми отличиями. 

В байтовой строке может быть либо печатный ASCII символ, либо код символа в шестнадцатеричной кодировке: ``b'123 test\x01\xcd'``

Способы создания байтовой строку:
```python
b'bytes' # поставить букву "b" перед литералом
>b'bytes'

'Байты'.encode('utf-8') # перекодировать строку
>b'\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd1\x8b'

# тоже перекодировка
bytes('bytes', encoding = 'utf-8')
b'bytes'

# преобразование массива **байт**
bytes([50, 100, 76, 72, 41])
b'2dLH)'
```

### Метод encode
строка.encode(кодировка) -> байтовая_строка

### Функция bytes (вообще-то конструктор объекта, но мы про них будем говорить позднее)
class bytes([source[, encoding[, errors]]])

Если в качестве источника (source) bytes принимает список чисел от 0 до 255 и возвращает байты, получающиеся применением функции *chr*.

Что делать с байтами? Хотя байтовые строки поддерживают практически все строковые методы, с ними мало что нужно делать. Обычно их надо записать в файл / прочесть из файла и преобразовать во что-либо другое. Для преобразования в строку используется метод **decode**.

### Метод decode
байтовая_строка.decode(кодировка) -> строка
```python
b'\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd1\x8b'.decode('utf-8')
>Байты
```    

## Bytearray
Массив байт, в отличие от строки байт - **изменяемый**

## Memoryview
>Справка: термин *protocol buffer* описывает взаимодействие объектов. А именно, по этому протоколу объекты предоставляют свою внутреннюю реализацию другим объектам. Этот механизм скрыт от программиста с помощью C_API

Memoryview объекты позволяют Python-коду (а не C_API) обращаться к внутренним данным объекта, который поддерживает *protocol buffer*. И работать с этими данными без копирования. Из встроенных типов этот протокол поддерживают *bytes* и *bytearray*.

В словах **без копирования** основная польза для программиста.

Отступление про копирование:

Многие из предопределённых типов данных Python — это типы неизменяемых объектов: числовые данные (int, float, complex), символьные строки (str), кортежи (tuple).

Например:

Cтрока ``s = 'abcdef'`` - это неизменяемый тип, так как в Python нельзя изменить некоторый одиночный символ в строке, например, через

``s[ 2 ] = 'z'``

не говоря уже о том, чтобы вставить символ внутрь строки. Но можно сделать

``s = s[:2] + 'z' = s[3:]``

И получить в результате, требуемую строку 'abzdef', только это будет совершенно другая строка, размещённая по совершенно другому адресу в памяти,а s — переустановленная ссылка на эту новую строку. Но изменить строку или её длину (её структурность) по текущей ссылке — невозможно. В этом и состоит неизменяемость объекта — это не константность, так как его значение можно изменить, но это будет уже ссылка на другой объект с этим новым значением.

Таким образом, строка

``s = s + 'a'``

приведет к копированию объекта. Большое количество таких неявных копирований приводит к замедлению программы.

И снова возвращаясь к memoryview:

В отличии от byte и bytearray - memoryview умеет обходиться без копирований. Потому что напрямую взаимодействует с данными в памяти.
```python
import time
for n in (100000, 200000, 300000, 400000):
    data = 'x' * n
    start = time.time()
    b = data
    while b:
        b = b[1:]
    print('bytes', n, time.time() - start)

for n in (100000, 200000, 300000, 400000):
    data = 'x' * n
    start = time.time()
    b = memoryview(data)
    while b:
        b = b[1:]
    print('memoryview', n, time.time() - start)
```    
Вывод:
```python
bytes 100000 0.200068950653
bytes 200000 0.938908100128
bytes 300000 2.30898690224
bytes 400000 4.27718806267
memoryview 100000 0.0100269317627
memoryview 200000 0.0208270549774
memoryview 300000 0.0303030014038
memoryview 400000 0.0403470993042
```

Как видно из примера, увеличение количества итераций не приводит к лавинному росту времени исполнения. Memoryview поддерживает slice (срезы). Таким образом этот тип подходит, когда нам нужно очень много срезов на одних бинарных данных.

Бесплатный бонус для программиста: "бесплатно" получаем возможность интерпретировать бинарные данные как int'ы, float'ы и прочее, прям как модуль struct.

>A memoryview has the notion of an element, which is the atomic memory unit handled by the originating object obj. For many simple types such as bytes and bytearray, an element is a single byte, but other types such as array.array may have bigger elements.

То есть memoryview оперирует элементами, которые предоставляет объект. И если для bytes и bytearray элемент это байт, то для других типов (например, array.array) элемент может быть больше чем байт (целое или float).

>TODO: расписать методы memoryview

***
# Контрольные вопросы
* [Кодировки символов](#codepages)
* [Работа со списками](#list)
* [Работа с кортежами](#tuple)
* [Работа со словарями](#dict)
* [Операции над множествами](#set)
* [Операции над строками](#strings)
* [Binary Sequence Types](#binary)