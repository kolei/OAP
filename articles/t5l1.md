# Тема 5. Библиотеки подпрограмм</br>Лекция 1     

В Питоне, в отличие от многих языков, нет деления на основной модуль и второстепенный.

В Си, точкой входя является функция main(), в Паскале основной модуль должен начинаться с ключевого слова *program*.

В Питоне все намного проще, все модули в принципе равнозначны, структура их одинакова и в принципе все они состоят из функций (мы помним что в глобальной области видимости писать моветон, да и все операции, которые записаны в глобальной области видимости, будут выполнятся при каждом импорте модуля. Иногда это полезно для инициализации модуля, но лучше так не делать)

Итак, обычно модули ничем не отличаются, но стобы выделить "главный" - в нем делают блок кода, который страбатывает только для запускаемого интерпретатором модуля:

```py
if __name__ == "__main__":
  # тут собственно и начинается работа программы
```

Модули бывают встроенные (поставляются вместе с языком) и загружаемые из сети.

Мы уже изучили несколько встроенных модулей, теперь посмотрим где брать сторонние пакеты (пакет это набор модулей решающих определенную задачу).

## Система управления пакетами PIP
Начиная с версии Питона 3.4, pip поставляется вместе с Питоном. Специально устанавливать его не надо, но вот в переменную path, как мы успели обнаружить, путь к нему не записывается. Поэтому если при попытке воспользоваться pip-ом вы увидите ошибку "pip не является внутренней или внешней командой...", то первым делом проверьте переменную path, или можно прописать полный путь к исполняемому файлу pip в команде.

Примеры установки стороннего пакета:

```
pip install numpy
# у вас может быть другой путь к pip
C:\Python34\Tools\Scripts\pip.exe install numpy
```

Если в вашем проекте используются сторонние пакеты и вы решили поделиться им или выложить в свободный доступ, то вам нужен механизм, который поможет быстро восстановить рабочую среду, т.е. установить сторонние пакеты, используемые вашим модулем.

Рекомендуется использовать файл requirements.txt (readthedocs.org), содержащий список команд для pip, который устанавливает необходимые версии зависимых пакетов. Наиболее распространенной является команда ``pip freeze > requirements.txt``, которая записывает текущий список пакетов среды в файл requirements.txt.

Для восстановления среды на другом компьютере достаточно выполнить команду:</br> ``pip -r requirements.txt``

### Что ещё умеет делать pip
* pip help - помощь по доступным командам.
* pip install package_name - установка пакета(ов).
* pip uninstall package_name - удаление пакета(ов).
* pip list - список установленных пакетов.
* pip show package_name - показывает информацию об установленном пакете.
* pip search - поиск пакетов по имени.
* pip --proxy user:passwd@proxy.server:port - использование с прокси.
* pip install -U - обновление пакета(ов).
* pip install --force-reinstall - при обновлении, переустановить пакет, даже если он последней версии.

### Где брать пакеты Python?
Пакеты Python можно легко найти в интернете. Большая часть популярных пакетов может быть найдена в PyPI (Python Package Index). Также множество пакетов Python можно найти на github, и bitbucket. Далее мы рассмотрим следующие методы установки пакетов Python:

* Установка из источника
* easy_install
* pip
* Другие способы

### Установка из источника
Это отличный навык, которому стоит научиться. Существуют более простые способы, которые мы рассмотрим позже. Тем не менее, существует ряд пакетов, которые нужно установить именно этим способом. Например, чтобы использовать easy_install, вам сначала нужно установить setuptools. Чтобы сделать это, вам нужно скачать tar или zip файл с PyPI (https://pypi.python.org/pypi/setuptools), и извлечь его в вашей системе. Далее, обратите внимание на файл setup.py. Откройте сессию терминала и измените каталог на папку, содержащую файл setup. После этого запустите следующую команду:

```
python setup.py install
```

Некоторые пакеты содержат в себе С код, например, заглавные файлы С, которые должны быть скомпилированы под пакет для корректной установки. В случае с Linux, у вас должен быть установленный C/C++ компилятор, так что вы можете установить пакет без головной боли. Возвращаясь к Windows, вам нужна правильная версия Visual Studio, для корректной компиляции пакета. Некоторые люди упоминают также и MingW, который можно использовать для этих целей, но я не знаю, как сделать так, чтобы это работало. Если в пакете присутствует установщик Windows, используйте его. В таком случае вы можете забыть о компиляции в принципе.

### Применение easy_install
После установки setuptools, вы можете использовать easy_install. Вы можете найти его в папке с установочными скриптами Python. Не забудьте добавить папку со скриптами в путь вашей системы, чтобы вы в дальнейшем смогли вызывать easy_install в командной строке, без указания его полного пути. Попробуйте выполнить запустить следующую команду, чтобы узнать больше об опциях easy_install:

```
easy_install -h
```

Если вам нужно начать установку пакета при помощи easy_install, вам нужно сделать следующее:

```
easy_install package_name
```

**easy_install** попытается скачать пакет с PyPI, скомпилировать его (если нужно) и установить его. Если вы зайдете в свою директорию site-packages, вы найдете файл под названием easy-install.pth, который содержит доступ ко всем пакетам, установленным через easy_install. Python использует этот файл, чтобы помочь в импорте модуля или пакета. Вы также можете указать easy_install на установку через URL или через путь на вашем компьютере. easy_install также может выполнить установку прямиком из файла tar. Вы можете использовать easy_install для обновления пакета, воспользовавшись функцией upgrade (или–U). И наконец, вы можете использовать easy_install для установки файла egg файлов. Вы можете найти эти файлы в PyPI, или в других источниках. Файлы egg – это особые zip файлы. На самом деле, если вы измените расширение на .zip, вы можете разархивировать файл egg.

Вот несколько примеров:

```
easy_install -U SQLAlchemy
easy_install http://example.com/path/to/MyPackage-1.2.3.tgz
easy_install /path/to/downloaded/package
```

Существует несколько проблем с easy_install. Он может попробовать установить пакет, пока он еще загружается. При помощи easy_install нельзя деинсталлировать пакет. Вам придется удалить пакет вручную и обновить файл easy-install.pth, удалив доступ к пакету. По этой, и многим другим причинам, в сообществе Python создали pip.

### Использование pip
Вы можете использовать pip для установки всего, что может установить easy_install, но сам процесс несколько отличается. Чтобы установить пакет, выполните следующее:

```
pip install package_name
```

А для обновления пакета, вам нужно сделать это:

```
pip install -U PackageName
```
Вам может понадобиться вызвать –h, чтобы получить полный список всего, что pip может сделать. В отличие от easy_install, pip может устанавливать формат wheel. Формат wheel – это ZIP архив, с именем файла, имеющим особый формат, и расширением **.whl**. Вы также можете установить wheel, при помощи его собственной командной строки. С другой стороны, pip не может выполнять установку файлов egg. Если вам нужно установить egg, вам придется воспользоваться easy_install.

### Кое-что о зависимостях
Преимущества в использовании easy_install и pip в том, что если пакет имеет зависимости от скрипта setup.py, то и easy_install, и pip попытаются установить и скачать этот скрипт. Это поможет вам избежать головной боли в той ситуации, когда вы пробуете новый пакет, и еще не понимаете, что пакет A зависит от пакетов B, C и D. При помощи easy_install или pip, вам не нужно об этом беспокоиться вообще.

### Подведем итоги
С этого момента, вы можете использовать любой пакет, который вам может понадобиться, конечно, если этот пакет поддерживается вашей версией Python. Существует множество инструментов, доступных программисту Python. Пока что пакеты – достаточно запутанная тема, тем не менее, вы знаете, как использовать необходимые инструменты, которые вы можете легко и быстро получить, для установки необходимого пакета.

## Использование библиотек Windows
Динамически подключаемые библиотеки (Dynamic Link Library - DLL). В операционных системах Microsoft Windows и IBM OS/2 — динамическая библиотека, позволяющая многократное использование различными программными приложениями. Эти библиотеки обычно имеют расширение DLL, OCX (для библиотек содержащих ActiveX), или DRV (для ряда системных драйверов). Формат файлов для DLL такой же, как для EXE-файлов Windows, т.е. Portable Executable (PE) для 32-битных и 64-битных приложений Windows. Так же, как EXE, DLL могут содержать секции кода, данных и ресурсов.

Питон тоже умеет работать с этими библиотеками, используя модуль **ctypes**. Этот модуль реализует поддержку Си совместимых типов данных (все DLL используют типы Си)

```pas
//пример описания экспортируемой функции в паскале
function Done: HRESULT; stdcall;
```

Модуль *ctypes* экспортирует объекты cdll, windll и oledll для загрузки DLL.

В Си есть несколько стандартов запуска функций: cdecl, stdcall. Объект cdll использует стандарт cdecl, а windll и oledll - stdcall. Обычно вместе с DLL распространяется заголовочный файл с описанием функций, их параметров и типом вызова.

Попробуем выполнить какую-нибудь функцию из DLL Windows.
Найдем каталог APPDATA используя библиотеку shell32.dll

```py
import ctypes

shell32 = ctypes.WinDLL("shell32.dll")

""" 
обратите внимание, в конце имени функции стоит буква 'W', она
означает что функция работает с юникодом, 
есть еще одноименная функция с буквой 'А' в конце, она работает с ASCII
А мы помним что от типа зависит длина буфера под строку
"""
SHGetFolderPath = shell32.SHGetFolderPathW
SHGetFolderPath.argtypes = (
    ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_uint32,
    ctypes.c_wchar_p)
SHGetFolderPath.restype = ctypes.c_uint32

CSIDL_LOCAL_APPDATA = 0x001c
MAX_PATH = 260

buf = ctypes.create_unicode_buffer(MAX_PATH)
res = SHGetFolderPath(0, CSIDL_LOCAL_APPDATA, 0, 0, buf)
if res == 0:
  print(buf.value)    
```

Еще один пример: загружаем библиотеку user32.dll и вызываем функцию, показывающую окно с сообщением (обратите внимание, вызывается функция с суффиксом 'W' - юникодная версия программы, еще существует аналогичная функция с суффиксом 'A' для ASCII)

```py
from ctypes import *
user32 = WinDLL("user32.dll")
user32.MessageBoxW(0, 'Ctypes is cool!', 'Ctypes', 0)
# ASCII вариант вызова функции - строковые параметры должны быть приведены в соответствующую кодировку
user32.MessageBoxA(0, 'Ctypes is cool!'.encode('ascii'), 'Ctypes'.encode('ascii'), 0)
```

