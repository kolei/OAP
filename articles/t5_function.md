<table style="width: 100%;"><tr><td style="width: 40%;">
<a href="../articles/cs_misc_types.md">Перечисления. Множества. Работа с датами. Кортежи.
</a></td><td style="width: 20%;">
<a href="../readme.md">Содержание
</a></td><td style="width: 40%;">
<a href="../articles/t5_exception.md">Исключения. Null.
</a></td><tr></table>

# Общие сведения о подпрограммах. Определение и вызов подпрограмм. Область видимости и время жизни переменной. Механизм передачи параметров. 

<!-- https://metanit.com/sharp/tutorial/2.8.php -->

* Методы
* Параметры методов
* Передача параметров по ссылке и значению. Выходные параметры
* Массив параметров и ключевое слово params
* Область видимости (контекст) переменных

## Методы

Если переменные хранят некоторые значения, то методы содержат собой набор операторов, которые выполняют определенные действия. По сути метод - это именованный блок кода, который выполняет некоторые действия.

Общее определение методов выглядит следующим образом:

```
[модификаторы] тип_возвращаемого_значения название_метода ([параметры])
{
    // тело метода
}
```

Модификаторы и параметры необязательны.

Например, по умолчанию консольная программа на языке C# должна содержать как минимум один метод - метод Main, который является точкой входа в приложение:

```cs
static void Main(string[] args)
{
     
}
```

Ключевое слово *static* является **модификатором**. Далее идет тип возвращаемого значения. В данном случае ключевое слово *void* указывает на то, что метод ничего не возвращает.

Далее идет название метода - *Main* и в скобках параметры - `string[] args`. И в фигурные скобки заключено тело метода - все действия, которые он выполняет. В данном случае метод Main пуст, он не содержит никаких операторов и по сути ничего не выполняет.

Определим еще пару методов:

```cs
using System;
 
namespace HelloApp
{
    class Program
    {
        static void Main(string[] args)
        {
             
        }

        static void SayHello()
        {
            Console.WriteLine("Hello");
        }
        static void SayGoodbye()
        {
            Console.WriteLine("GoodBye");
        }
    }
}
```

В данном случае определены еще два метода: *SayHello* и *SayGoodbye*. Оба метода определены в рамках класса Program, они имеют модификатор *static*, а в качестве возвращаемого типа для них определен тип *void*. То есть данные методы ничего не возвращают, просто производят некоторые действия. И также оба метода не имеют никаких параметров, поэтому после названия метода указаны пустые скобки.

Оба метода выводят на консоль некоторую строку. Причем для вывода на консоль методы используют другой метод, который определен в .NET по умолчанию - Console.WriteLine().

Но если мы запустим даную программу, то мы не увидим никаких сообщений, которые должны выводить методы SayHello и SayGoodbye. Потому что стартовой точкой является метод Main. При запуске программы выполняется только метод Main и все операторы, которые составляют тело этого метода. Все остальные методы не выполняются.

### Вызов методов

Чтобы использовать методы SayHello и SayGoodbye в программе, нам надо вызвать их в методе Main.

Для вызова метода указывается его имя, после которого в скобках идут значения для его параметров (если метод принимает параметры).

```
название_метода (значения_для_параметров_метода);
```

Например, вызовем методы SayHello и SayGoodbye:

```cs
using System;
 
namespace HelloApp
{
    class Program
    {
        static void Main(string[] args)
        {
            SayHello();
            SayGoodbye();
 
            Console.ReadKey();
        }
 
        static void SayHello()
        {
            Console.WriteLine("Hello");
        }
        static void SayGoodbye()
        {
            Console.WriteLine("GoodBye");
        }
    }
}
```

Консольный вывод программы:

```
Hello
GoodBye
```

Преимуществом методов является то, что их можно повторно и многократно вызывать в различных частях программы. Например, в примере выше в двух методах для вывода строки на консоль используется метод Console.WriteLine.

### Возвращение значения

Метод может возвращать значение, какой-либо результат. В примере выше были определены два метода, которые имели тип void. Методы с таким типом не возвращают никакого значения. Они просто выполняют некоторые действия.

Если метод имеет любой другой тип, отличный от void, то такой метод обязан вернуть значение этого типа. Для этого применяется оператор **return**, после которого идет возвращаемое значение:

```
return возвращаемое значение;
```

Например, определим еще пару методов:

```cs
static string GetHello()
{
    return "Hello";
}
static int GetSum()
{
    int x = 2;
    int y = 3;
    int z = x + y;
    return z;
}
```

Метод GetHello имеет тип *string*, следовательно, он должен возвратить строку. Поэтому в теле метода используется оператор **return**, после которого указана возвращаемая строка.

Метод GetSum имеет тип *int*, следовательно, он должен возвратить значение типа int - целое число. Поэтому в теле метода используется оператор return, после которого указано возвращаемое число (в данном случае результат суммы переменных x и y).

После оператора return также можно указывать сложные выражения, которые возвращают определенный результат. Например:

```cs
static int GetSum()
{
    int x = 2;
    int y = 3;
    return x + y;
}
```

При этом методы, которые в качестве возвращаемого типа имеют любой тип, отличный от void, обязательно должны использовать оператор return для возвращения значения. Например, следующее определение метода некорректно:

```cs
static string GetHello()
{
    Console.WriteLine("Hello");
}
```

Также между возвращаемым типом метода и возвращаемым значением после оператора return должно быть соответствие. Например, в следующем случае возвращаемый тип - int, но метод возвращает строку (тип string), поэтому такое определение метода некорректно:

```cs
static int GetSum()
{
    int x = 2;
    int y = 3;
    return "5"; // ошибка - надо возвращать число
}
```

Результат методов, который возвращают значение, мы можем присвоить переменным или использовать иным образом в программе:

```cs
static void Main(string[] args)
{
    string message = GetHello();
    int sum = GetSum();

    Console.WriteLine(message);  // Hello
    Console.WriteLine(sum);     // 5

    Console.ReadKey();
}

static string GetHello()
{
    return "Hello";
}
static int GetSum()
{
    int x = 2;
    int y = 3;
    return x + y;
}
```

Метод GetHello возвращает значение типа string. Поэтому мы можем присвоить это значение какой-нибудь переменной типа string: `string message = GetHello();`

Второй метод - GetSum - возвращает значение типа int, поэтому его можно присвоить переменной, которая принимает значение этого типа: `int sum = GetSum();`.

### Выход из метода

Оператор return не только возвращает значение, но и производит выход из метода. Поэтому он должен определяться после отальных инструкций. Например:

```cs
static string GetHello()
{
    return "Hello";
    Console.WriteLine("After return");
}
```

С точки зрения синтаксиса данный метод корректен, однако его инструкция Console.WriteLine("After return") не имеет смысла - она никогда не выполнится, так как до ее выполнения оператор return возвратит значение и произведет выход из метода.

Однако мы можем использовать оператор return и в методах с типам void. В этом случае после оператора return не ставится никакого возвращаемого значения (ведь метод ничего не возвращает). Типичная ситуация - в зависимости от опеределенных условий произвести выход из метода:

```cs
static void SayHello()
{
    int hour = 23;
    if(hour > 22)
    {
        return;
    }
    else
    {
        Console.WriteLine("Hello");
    }
}
```

### Сокращенная запись методов

Если метод в качестве тела определяет только одну инструкцию, то мы можем сократить определение метода. Например, допустим у нас есть метод:

```cs
static void SayHello()
{
    Console.WriteLine("Hello");
}
```

Мы можемего сократить следующим образом:

```cs
static void SayHello() => Console.WriteLine("Hello");
```

То есть после списка параметров ставится знак равно и больше чем, после которого идет выполняемая инструкция.

Подобным образом мы можем сокращать методы, которые возвращают значение:

```cs
static string GetHello()
{
    return "hello";
}
```

Анлогичен следующему методу:

```cs
static string GetHello() => "hello";
```

## Параметры методов

Параметры позволяют передать в метод некоторые входные данные. Например, определеим метод, который складывает два числа:

```cs
static int Sum(int x, int y)
{
    return x + y;
}
```

Метод Sum имеет два параметра: x и y. Оба параметра представляют тип int. Поэтому при вызове данного метода нам обязательно надо передать на место этих параметров два числа.

```cs
static void Main(string[] args)
{
    int result = Sum(10, 15);
    Console.WriteLine(result);  // 25
        
    Console.ReadKey();
}
static int Sum(int x, int y)
{
    return x + y;
}
```

При вызове метода Sum значения передаются параметрам по позиции. Например, в вызове Sum(10, 15) число 10 передается параметру x, а число 15 - параметру y. Значения, которые передаются параметрам, еще называются аргументами. То есть передаваемые числа 10 и 15 в данном случае являются аргументами.

Иногда можно встретить такие определения как формальные параметры и фактические параметры. Формальные параметры - это собственно параметры метода (в данном случае x и y), а фактические параметры - значения, которые передаются формальным параметрам. То есть фактические параметры - это и есть аргументы метода.

Передаваемые параметру значения могут представлять значения переменных или результат работы сложных выражений, которые возвращают некоторое значение:

```cs
static void Main(string[] args)
{
    int a = 25;
    int b = 35;
    int result = Sum(a, b);
    Console.WriteLine(result);  // 60

    result = Sum(b, 45);
    Console.WriteLine(result);  // 80

    result = Sum(a + b + 12, 18); // "a + b + 12" представляет значение параметра x
    Console.WriteLine(result);  // 90

    Console.ReadKey();
}
static int Sum(int x, int y)
{
    return x + y;
}
```

Если параметрами метода передаются значения переменных, которые представляют базовые примитивные типы (за исключением типа object), то таким переменным должно быть присвоено значение. Например, следующая программа не скомпилируется:

```cs
static void Main(string[] args)
{
    int a;
    int b = 9;
    Sum(a, b);  // Ошибка - переменной a не присвоено значение

    Console.ReadKey();
}
static int Sum(int x, int y)
{
    return x + y;
}
```

При передаче значений параметрам важно учитывать тип параметров: между аргументами и параметрами должно быть соответствие по типу. Например:

```cs
static void Main(string[] args)
{
    Display("Tom", 24); // Name: Tom  Age: 24

    Console.ReadKey();
}
static void Display(string name, int age)
{
    Console.WriteLine($"Name: {name}  Age: {age}");
}
```

В данном случае первый параметр метода Display представляет тип string, поэтому мы должны передать этому параметру значение типа string, то есть строку. Второй параметр представляет тип int, поэтому должны передать ему целое число, которое соответствует типу int.

Другие данные параметрам мы передать не можем. Например, следующий вызов метода Display будет ошибочным:

```cs
Display(45, "Bob"); // Ошибка! несоответствие значений типам параметров
```

### Необязательные параметры

По умолчанию при вызове метода необходимо предоставить значения для всех его параметров. Но C# также позволяет использовать необязательные параметры. Для таких параметров нам необходимо объявить значение по умолчанию. Также следует учитывать, что после необязательных параметров все последующие параметры также должны быть необязательными:

```cs
static int OptionalParam(int x, int y, int z=5, int s=4)
{
    return x + y + z + s;
}
```

Так как последние два параметра объявлены как необязательные, то мы можем один из них или оба опустить:

```cs
static void Main(string[] args)
{
    OptionalParam(2, 3);
 
    OptionalParam(2,3,10);
 
    Console.ReadKey();
}
```

### Именованные параметры

В предыдущих примерах при вызове методов значения для параметров передавались в порядке объявления этих параметров в методе. Но мы можем нарушить подобный порядок, используя именованные параметры:

```cs
static int OptionalParam(int x, int y, int z=5, int s=4)
{
    return x + y + z + s;
}
static void Main(string[] args)
{
    OptionalParam(x:2, y:3);
     
    //Необязательный параметр z использует значение по умолчанию
    OptionalParam(y:2, x:3, s:10);
 
    Console.ReadKey();
}
```

## Передача параметров по ссылке и значению. Выходные параметры

Существует два способа передачи параметров в метод в языке C#: **по значению** и **по ссылке**.

### Передача параметров по значению

Наиболее простой способ передачи параметров представляет передача по значению, по сути это обычный способ передачи параметров:

```cs
static void Main(string[] args)
{
    Sum(10, 15);        // параметры передаются по значению
    Console.ReadKey();
}
static int Sum(int x, int y)
{
    return x + y;
}
```

### Передача параметров по ссылке и модификатор ref

При передаче параметров по ссылке перед параметрами используется модификатор **ref**:

```cs
static void Main(string[] args)
{
    int x = 10;
    int y = 15;
    Addition(ref x, y); // вызов метода
    Console.WriteLine(x);   // 25
 
    Console.ReadLine();
}
// параметр x передается по ссылке
static void Addition(ref int x, int y)
{
    x += y;
}
```

Обратите внимание, что модификатор **ref** указывается, как при объявлении метода, так и при его вызове в методе Main.

### Сравнение передачи по значению и по ссылке

В чем отличие двух способов передачи параметров? При передаче по значению метод получает не саму переменную, а ее копию. А при передаче параметра по ссылке метод получает адрес переменной в памяти. И, таким образом, если в методе изменяется значение параметра, передаваемого по ссылке, то также изменяется и значение переменной, которая передается на его место.

Рассмотрим два аналогичных примера. Первый пример - передача параметра по значению:

```cs
static void Main(string[] args)
{
    int a = 5;
    Console.WriteLine($"Начальное значение переменной a = {a}");

    //Передача переменных по значению
    //После выполнения этого кода по-прежнему a = 5, так как мы передали лишь ее копию
    IncrementVal(a);
    Console.WriteLine($"Переменная a после передачи по значению равна = {a}");
    Console.ReadKey();
}
// передача по значению
static void IncrementVal(int x)
{
    x++;
    Console.WriteLine($"IncrementVal: {x}");
}
```

Консольный вывод:

```
Начальное значение переменной a = 5
IncrementVal: 6
Переменная a после передачи по значению равна = 5
```

При вызове метод *IncrementVal* получает копию переменной `a` и увеличивает значение этой копии. Поэтому в самом методе *IncrementVal* мы видим, что значение параметра `x` увеличилось на 1, но после выполнения метода переменная `a` имеет прежнее значение - 5. То есть изменяется копия, а сама переменная не изменяется.

Второй пример - аналогичный метод с передачей параметра по ссылке:

```cs
static void Main(string[] args)
{
    int a = 5;
    Console.WriteLine($"Начальное значение переменной a  = {a}");
    //Передача переменных по ссылке
    //После выполнения этого кода a = 6, так как мы передали саму переменную
    IncrementRef(ref a);
    Console.WriteLine($"Переменная a после передачи ссылке равна = {a}");
        
    Console.ReadKey();
}
// передача по ссылке
static void IncrementRef(ref int x)
{
    x++;
    Console.WriteLine($"IncrementRef: {x}");
}
```

Консольный вывод:

```
Начальное значение переменной a = 5
IncrementRef: 6
Переменная a после передачи по ссылке равна = 6
```

В метод *IncrementRef* передается ссылка на саму переменную a в памяти. И если значение параметра в *IncrementRef* изменяется, то это приводит и к изменению переменной a, так как и параметр и переменная указывают на один и тот же адрес в памяти.

### Выходные параметры. Модификатор out

Выше мы использовали входные параметры. Но параметры могут быть также выходными. Чтобы сделать параметр выходным, перед ним ставится модификатор out:

```cs
static void Sum(int x, int y, out int a)
{
    a = x + y;
}
```

Здесь результат возвращается не через оператор return, а через выходной параметр. Использование в программе:

```cs
static void Main(string[] args)
{
    int x = 10;
     
    int z;
     
    Sum(x, 15, out z);
     
    Console.WriteLine(z);
 
    Console.ReadKey();
}
```

Причем, как и в случае с *ref* ключевое слово *out* используется как при определении метода, так и при его вызове.

Также обратите внимание, что методы, использующие такие параметры, обязательно должны присваивать им определенное значение. То есть следующий код будет недопустим, так как в нем для out-параметра не указано никакого значения:

```cs
static void Sum(int x, int y, out int a)
{
    Console.WriteLine(x+y);
}
```

Прелесть использования подобных параметров состоит в том, что по сути мы можем вернуть из метода не один вариант, а несколько. Например:

```cs
static void Main(string[] args)
{
    int x = 10;
    int area;
    int perimetr;
    GetData(x, 15, out area, out perimetr);
    Console.WriteLine("Площадь : " + area);
    Console.WriteLine("Периметр : " + perimetr);
 
    Console.ReadKey();
}
static void GetData(int x, int y, out int area, out int perim)
{
    area= x * y;
    perim= (x + y)*2; 
}
```

Здесь у нас есть метод GetData, который, допустим, принимает стороны прямоугольника. А два выходных параметра мы используем для подсчета площади и периметра прямоугольника.

По сути, как и в случае с ключевым словом ref, ключевое слово out применяется для передачи аргументов по ссылке. Однако в отличие от ref для переменных, которые передаются с ключевым словам out, не требуется инициализация. И кроме того, вызываемый метод должен обязательно присвоить им значение.

Стоит отметить, что начиная с версии C# 7.0 можно определять переменные в непосредственно при вызове метода. То есть вместо:

```cs
int x = 10;
int area;
int perimetr;
GetData(x, 15, out area, out perimetr);
Console.WriteLine($"Площадь : {area}");
Console.WriteLine($"Периметр : {perimetr}");
```

Мы можем написать:

```cs
int x = 10;
GetData(x, 15, out int area, out int perimetr);
Console.WriteLine($"Площадь : {area}");
Console.WriteLine($"Периметр : {perimetr}");
```

### Входные параметры. Модификатор in

Кроме выходных параметров с модификатором *out* метод может использовать входные параметры с модификатором *in*. Модификатор *in* указывает, что данный параметр будет передаваться в метод по ссылке, однако внутри метода его значение параметра нельзя будет изменить. Например, возьмем следующий метод:

```cs
static void GetData(in int x, int y, out int area, out int perim)
{
    // x = x + 10; нельзя изменить значение параметра x
    y = y + 10;
    area = x * y;
    perim = (x + y) * 2;
}
```

В данном случае через параметры `x` и `y` в метод передаются значения, но в самом методе можно изменить только значение параметра `y`, так как параметр `x` указан с модификатором *in*.

## Массив параметров и ключевое слово params

Во всех предыдущих примерах мы использовали постоянное число параметров. Но, используя ключевое слово params, мы можем передавать неопределенное количество параметров:

```cs
static void Addition(params int[] integers)
{
    int result = 0;
    for (int i = 0; i < integers.Length; i++)
    {
        result += integers[i];
    }
    Console.WriteLine(result);
}
 
static void Main(string[] args)
{
    Addition(1, 2, 3, 4, 5);
     
    int[] array = new int[] { 1, 2, 3, 4 };
    Addition(array);
 
    Addition();
    Console.ReadLine();
}
```

Сам параметр с ключевым словом params при определении метода должен представлять одномерный массив того типа, данные которого мы собираемся использовать. При вызове метода на место параметра с модификатором params мы можем передать как отдельные значения, так и массив значений, либо вообще не передавать параметры.

Если же нам надо передать какие- то другие параметры, то они должны указываться до параметра с ключевым словом params:

```cs
//Так работает
static void Addition( int x, string mes, params int[] integers)
{}
```

Вызов подобного метода:

```cs
Addition(2, "hello", 1, 3, 4);
```

Однако после параметра с модификатором params мы НЕ можем указывать другие параметры. То есть следующее определение метода недопустимо:

```cs
//Так НЕ работает
static void Addition(params int[] integers, int x, string mes)
{}
```

### Массив в качестве параметра

Также этот способ передачи параметров надо отличать от передачи массива в качестве параметра:

```cs
// передача параметра с params
static void Addition(params int[] integers)
{
    int result = 0;
    for (int i = 0; i < integers.Length; i++)
    {
        result += integers[i];
    }
    Console.WriteLine(result);
}
// передача массива
static void AdditionMas(int[] integers, int k)
{
    int result = 0;
    for (int i = 0; i < integers.Length; i++)
    {
        result += (integers[i]*k);
    }
    Console.WriteLine(result);
}
 
static void Main(string[] args)
{
    Addition(1, 2, 3, 4, 5);
 
    int[] array = new int[] { 1, 2, 3, 4 };
    AdditionMas(array, 2);
 
    Console.ReadLine();
}
```

Так как метод AdditionMas принимает в качестве параметра массив без ключевого слова params, то при его вызове нам обязательно надо передать в качестве параметра массив.

## Область видимости (контекст) переменных

Каждая переменная доступна в рамках определенного контекста или области видимости. Вне этого контекста переменная уже не существует.

Существуют различные контексты:

**Контекст класса**. Переменные, определенные на уровне класса, доступны в любом методе этого класса

**Контекст метода**. Переменные, определенные на уровне метода, являются локальными и доступны только в рамках данного метода. В других методах они недоступны

**Контекст блока кода**. Переменные, определенные на уровне блока кода, также являются локальными и доступны только в рамках данного блока. Вне своего блока кода они не доступны.

Например, пусть класс Program определен следующим образом:

```cs
class Program // начало контекста класса
{
    static int a = 9; // переменная уровня класса
     
    static void Main(string[] args) // начало контекста метода Main
    {
        int b = a - 1; // переменная уровня метода
 
        { // начало контекста блока кода
             
            int c = b - 1; // переменная уровня блока кода
 
        }  // конец контекста блока кода, переменная с уничтожается
 
        //так нельзя, переменная c определена в блоке кода
        //Console.WriteLine(c);
 
        //так нельзя, переменная d определена в другом методе
        //Console.WriteLine(d);
 
        Console.Read();
 
    } // конец контекста метода Main, переменная b уничтожается
 
    void Display() // начало контекста метода Display
    {
        // переменная a определена в контексте класса, поэтому доступна
        int d = a + 1;
 
    } // конец конекста метода Display, переменная d уничтожается
 
} // конец контекста класса, переменная a уничтожается
```

Здесь определенно четыре переменных: a, b, c, d. Каждая из них существует в своем контексте. Переменная a существует в контексте всего класса Program и доступна в любом месте и блоке кода в методах Main и Display.

Переменная b существует только в рамках метода Main. Также как и переменная d существует в рамках метода Display. В методе Main мы не можем обратиться к переменной d, так как она в другом контексте.

Переменная c существует только в блоке кода, границами которого являются открывающая и закрывающая фигурные скобки. Вне его границ переменная c не существует и к ней нельзя обратиться.

Нередко границы различных контекстов можно ассоциировать с открывающимися и закрывающимися фигурными скобками, как в данном случае, которые задают пределы блока кода, метода, класса.

При работе с переменными надо учитывать, что локальные переменные, определенные в методе или в блоке кода, скрывают переменные уровня класса, если их имена совпадают:

```cs
class Program
{
    static int a = 9; // переменная уровня класса
     
    static void Main(string[] args)
    {
        int a = 5; // скрывает переменную a, которая объявлена на уровне класса
        Console.WriteLine(a); // 5
    }
}
```

При объявлении переменных также надо учитывать, что в одном контексте нельзя определить несколько переменных с одним и тем же именем.

<table style="width: 100%;"><tr><td style="width: 40%;">
<a href="../articles/cs_misc_types.md">Перечисления. Множества. Работа с датами. Кортежи.
</a></td><td style="width: 20%;">
<a href="../readme.md">Содержание
</a></td><td style="width: 40%;">
<a href="../articles/t5_exception.md">Исключения. Null.
</a></td><tr></table>